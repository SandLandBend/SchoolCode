(************** Content-type: application/mathematica **************                     CreatedBy='Mathematica 4.2'                    Mathematica-Compatible NotebookThis notebook can be used with any Mathematica-compatibleapplication, such as Mathematica, MathReader or Publicon. The datafor the notebook starts with the line containing stars above.To get the notebook into a Mathematica-compatible application, doone of the following:* Save the data starting with the line of stars above into a file  with a name ending in .nb, then open the file inside the  application;* Copy the data starting with the line of stars above to the  clipboard, then use the Paste menu command inside the application.Data for notebooks contains only printable 7-bit ASCII and can besent directly in email or through ftp in text mode.  Newlines can beCR, LF or CRLF (Unix, Macintosh or MS-DOS style).NOTE: If you modify the data for this notebook not in a Mathematica-compatible application, you must delete the line below containingthe word CacheID, otherwise Mathematica-compatible applications maytry to use invalid cache data.For more information on notebooks and Mathematica-compatible applications, contact Wolfram Research:  web: http://www.wolfram.com  email: info@wolfram.com  phone: +1-217-398-0700 (U.S.)Notebook reader applications are available free of charge from Wolfram Research.*******************************************************************)(*CacheID: 232*)(*NotebookFileLineBreakTestNotebookFileLineBreakTest*)(*NotebookOptionsPosition[     84134,       1722]*)(*NotebookOutlinePosition[     85231,       1757]*)(*  CellTagsIndexPosition[     85187,       1753]*)(*WindowFrame->Normal*)Notebook[{Cell[TextData[{  "Here are the instructions for proper use of this program.\n1.  Please ",  StyleBox["don't touch",    FontSlant->"Italic"],  " Modules in Cells 0 through 11 (blue text at cell bottom\n     are test \statements that may be kept as is, or commented out).  \n     Code is \"ready \to run\" assuming download was OK.\n2.  Execute Cells 0 through 11, in that \order, to initialize all necessary modules. \n     Shortcut fo ",  StyleBox["Mathematica",    FontSlant->"Italic"],  " 4 and 5: select Kernel -> Evaluation -> Evaluate Initialization.\n3.  \Cells 12A through 12D  contain test driver programs used to check the code.   \\n     It is recommended to run at least two (especially 12B, which is \documented \n     in Addendum B of the exam) to verify that the downloaded NB \works as expected.\n4.  Cell 13 solves the Question 5 problem of the ",  "2013",  " Final Exam with a very coarse mesh.  \n     It may be used as a \\"template\" for doing the finer mesh case in another cell, say Cell 14.\n5.  \If the plots produced by  running your driver program appear too small, \one-click on the \n     first plot  (only)  with the mouse, grab a corner \\"handle\" and enlarge it.  Then rerun \n     the  driver program. \n6. ",  StyleBox[" Plotting module news update",    FontSlant->"Italic"],  ". These are provided in 3 cells: 9A, 9B, 9C.\n     o  Cell 9A: A new and \spiffier mesh plotter, called Plot2DMesh, written Nov 2009.  \n         \Publication quality and fast but barely debugged and still undocumented.  \n  \       Report any problems to instructor.\n     o  Two contour plot modules \are provided: \n         Cell 9B: polygon plotter \ContourPlotNodeFuncOver2DMesh. - Old, reliable,\n         but low quality and \slow. Nsub=8 or 12  usually gives acceptable results for\n         coarse \meshes whereas Nsub=4  should be OK for finer meshes.\n         Cell 9C: band \plotter ContourBandPlotNodeFuncOver2DMesh. New, \n         fast and \publication quality but barely debugged and still undocumented. \n         \Report any problems to instructor.\n7. To move a plot to a document: select \cell that holds plot by clicking on margin, then\n     Edit -> Save Selection \As ->  Encapsulated PostScript (eps) and give file a name. \n     (Note: this \is the sequence used in ",  StyleBox["Mathematica",    FontSlant->"Italic"],  " 4.2-5.2, might have changed in 6.0)\n     Quit ",  StyleBox["Mathematica",    FontSlant->"Italic"],  ", pick file with Adobe Illustrator (or equivalent) to clean it up as \n    \ needed, and include in document.  To include in a Word document, convert to \\n     a Microsoft  accepted format, such as jpeg, first."}], "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 0.810117, 0.330022]],Cell[TextData[{  "Cell 0.   Global variables dependent on ",  StyleBox["Mathematica",    FontSlant->"Italic"],  " vresion"}], "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "DisplayChannel=$DisplayFunction;\nIf [$VersionNumber>=6.0, \DisplayChannel=Print]; \n  (* fix for Mathematica 6 & later *)",  StyleBox["  ",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell[TextData[StyleBox["Off[General::spell1]; Off[General::spell];",  FontColor->RGBColor[0, 0, 1]]], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 1.  Shape Functions of 4-Node Bilinear Quadrilateral.  This is \the same module usedin structural problems and described in Chapter 17.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "Quad4IsoPShapeFunDer[ncoor_,qcoor_]:= Module[\n  {Nf,dNx,dNy,dN\[Xi],dN\\[Eta],i,J11,J12,J21,J22,Jdet,\[Xi],\[Eta],x,y},\n  {\[Xi],\[Eta]}=qcoor; \n  \ Nf={(1-\[Xi])*(1-\[Eta]),(1+\[Xi])*(1-\[Eta]),(1+\[Xi])*(1+\[Eta]),(1-\[Xi])*\(1+\[Eta])}/4;\n   dN\[Xi] ={-(1-\[Eta]), \(1-\[Eta]),(1+\[Eta]),-(1+\[Eta])}/4;\n   dN\[Eta]= \{-(1-\[Xi]),-(1+\[Xi]),(1+\[Xi]), (1-\[Xi])}/4;\n   \x=Table[ncoor[[i,1]],{i,4}]; y=Table[ncoor[[i,2]],{i,4}];\n   J11=dN\[Xi].x; \J21=dN\[Xi].y; J12=dN\[Eta].x; J22=dN\[Eta].y;\n   \Jdet=Simplify[J11*J22-J12*J21];\n   dNx= ( J22*dN\[Xi]-J21*dN\[Eta])/Jdet;  \dNx=Simplify[dNx];\n   dNy= (-J12*dN\[Xi]+J11*dN\[Eta])/Jdet;  \dNy=Simplify[dNy];\n   Return[{Nf,dNx,dNy,Jdet}]\n];\n",  StyleBox["\nClearAll[a,b,\[Xi],\[Eta]];\nncoor={{0,0},{a,0},{a,b},{0,b}};\n\{Nf,Nx,Ny,Jdet}=Simplify[Quad4IsoPShapeFunDer[ncoor,{\[Xi],\[Eta]}]];\n\Print[{Nf,Nx,Ny,Jdet}];",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 2.  Gauss quadrature rule information for quadrilaterals.  \This is the same module usedin  structures problems and described in Chapter 17.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell["\<\QuadGaussRuleInfo[{rule_,numer_},point_]:= Module[ {xi,eta,p1,p2,i1,i2,w1,w2,k,info=Null},  If [Length[rule]==2,  {p1,p2}=rule, p1=p2=rule];  If [Length[point]==2, {i1,i2}=point,       k=point; i2=Floor[(k-1)/p1]+1; i1=k-p1*(i2-1) ];  {xi, w1}=  LineGaussRuleInfo[{p1,numer},i1];  {eta,w2}=  LineGaussRuleInfo[{p2,numer},i2];  info={{xi,eta},w1*w2};  If [numer, Return[N[info]], Return[Simplify[info]]];];LineGaussRuleInfo[{rule_,numer_},point_]:= Module[  {g2={-1,1}/Sqrt[3],w3={5/9,8/9,5/9},    g3={-Sqrt[3/5],0,Sqrt[3/5]},    w4={(1/2)-Sqrt[5/6]/6, (1/2)+Sqrt[5/6]/6,       (1/2)+Sqrt[5/6]/6, (1/2)-Sqrt[5/6]/6},   g4={-Sqrt[(3+2*Sqrt[6/5])/7],-Sqrt[(3-2*Sqrt[6/5])/7],        Sqrt[(3-2*Sqrt[6/5])/7], Sqrt[(3+2*Sqrt[6/5])/7]},   g5={-Sqrt[5+2*Sqrt[10/7]],-Sqrt[5-2*Sqrt[10/7]],0,         Sqrt[5-2*Sqrt[10/7]], Sqrt[5+2*Sqrt[10/7]]}/3,   w5={322-13*Sqrt[70],322+13*Sqrt[70],512,       322+13*Sqrt[70],322-13*Sqrt[70]}/900,   i=point,p=rule,info={Null,0}},   If [p==1, info={0,2}];  If [p==2, info={g2[[i]],1}];  If [p==3, info={g3[[i]],w3[[i]]}];   If [p==4, info={g4[[i]],w4[[i]]}];  If [p==5, info={g5[[i]],w5[[i]]}];  If [numer, Return[N[info]], Return[Simplify[info]]];];\\>", "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 3.   Formation of \"element stiffness\" matrix of 4-node quad \for Poisson's equation.    Can be used for many problems: potential fluid flow, electrostatics, torsion, \etc,  including the  steady-state heat conduction problem of the 2009 Final Exam.  Relevant to part of Question 2 of that exam.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "Quad4IsoPPoissonStiffness[ncoor_,mprop_,fprop_,opt_]:= \n  \Module[{i,k,l,p=2,num=False,Emat,th=1,h,qcoor,w,\n         kcond, \Nf,Nx,Ny,Jdet,Be,Ke=Table[0,{4},{4}]},\n  If [Length[fprop]>0, \th=fprop[[1]]];\n  If [Length[mprop]>0, kcond=mprop[[1]], kcond=mprop];  \n  \If [Length[opt]>0,   num=opt[[1]]];\n  If [Length[opt]>1,   p  =opt[[2]]];\n  \If [p<1||p>4, Print[\"p out of range\"]; Return[Null]];\n  For [k=1, k<=p, \k++,  \n    For [l=1, l<=p, l++, \n        {qcoor,w}=        \QuadGaussRuleInfo[{p,num},{k,l}];\n        {Nf,Nx,Ny,Jdet}=  \Quad4IsoPShapeFunDer[ncoor,qcoor];\n        If [num, \{Nf,Nx,Ny,Jdet}=N[{Nf,Nx,Ny,Jdet}]];\n        If [Length[th]==0, h=th, \h=th.Nf]; Be={Nx,Ny}; \n        Ke +=w*Jdet*kcond*h*(Transpose[Be].Be);     \n\        ]; \n      ]; Return[Simplify[Ke]]\n   ];\n",  StyleBox["   \n",    FontColor->RGBColor[1, 0, 0]],  StyleBox["ClearAll[a,b,k,h];  h=1;  kcond=6;\n\Ke=Quad4IsoPPoissonStiffness[{{0,0},{a,0},{a,b},{0,b}},\n  \kcond,{h},{False,2}]; (* rectangle, symbolic eval, 2x2 Gauss rule  *)\nPrint[\\"Ke=\",Ke//MatrixForm]; Print[\"eigs of Ke=\",Eigenvalues[Ke]];\n\Ke=Quad4IsoPPoissonStiffness[{{0,0},{a,0},{a,b},{0,b}},\n  \kcond,{h},{False,1}]; (* rectangle, symbolic eval, 1x1 Gauss rule  *)\nPrint[\\"Ke=\",Ke//MatrixForm]; Print[\"eigs of Ke=\",Eigenvalues[Ke]];",    CellFrame->True,    FontColor->RGBColor[0, 0, 1],    Background->GrayLevel[0.833326]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.833326]],Cell["\<\Cell 4.   Computes consistent  node forces fe due to body source \(called s) within element.  This is constant over element if specified as a scalar s, or varies \bilinearly if given as {s1,s2,s3,s4}.  For the heat conduction problem, this \source is the heat production (if +)  or comsumption (if -) per body volume.   Relevant to \part ofQuestion 3 of the 2009 Final Exam.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "Quad4IsoPPoissonSourceForces[ncoor_,mprop_,fprop_,forprop_,\n   opt_]:= \Module[{i,k,l,p=2,num=False,Emat,th=1,h,qcoor,c,w,\n   \s=0,source,Nx,Ny,Jdet,fe=Table[0,{4}]},\n  If [Length[fprop]>0, \th=fprop[[1]]];\n  If [Length[forprop]>0, s=forprop[[1]], Return[fe] ]; \n  \If [Length[opt]>0, num=opt[[1]]];\n  If [Length[opt]>1, p  =opt[[2]]];\n  If \[p<1||p>4, Print[\"p out of range\"];Return[Null]];\n  For [k=1, k<=p, k++, \n\    For [l=1, l<=p, l++, \n        {qcoor,w}=        \QuadGaussRuleInfo[{p,num},{k,l}];\n        {Nf,Nx,Ny,Jdet}=  \Quad4IsoPShapeFunDer[ncoor,qcoor];\n         If [num, \{Nf,Nx,Ny,Jdet}=N[{Nf,Nx,Ny,Jdet}]];\n         If [Length[th]==0, h=th, \h=th.Nf]; c=w*Jdet*h;\n         If [Length[s ]==0, source=s, source=s.Nf]; \n \        fe+=w*Jdet*source*h*Nf;     \n        ]; \n      ]; \Return[Simplify[fe]]\n   ];\n   \n",  StyleBox["ClearAll[a,b,k,h,s,s1,s2,s3,s4];  \n\ncoor={{0,0},{a,0},{a,b},{0,b}};\n\fe=Quad4IsoPPoissonSourceForces[ncoor,{k},{h},{s},{False,2}];\n\Print[\"Constant source node forces fe=\",fe];\n\fe=Quad4IsoPPoissonSourceForces[ncoor,{k},{h},{{s1,s2,s3,s4}},\n    \{False,2}];\nPrint[\"Varying source node forces fe=\",fe];",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 5.   Computes consistent  node forces fe due to specified \normal flux qn over element sides.This is entered as  q={q12,q23,q34,q41} in the second entry of forprop.   \Fluxes are assumed constant over each side.   A flux is positive it it flows away from element, \that is, along its exterior normal.If the flux over a side is unknown (e.g. internal side) enter zero.  Trailing \zeros may be omitted, for example qn={0,q23} means flux is known only over  side 2-3. If all fluxes are \unknown, an empty list may be given, or the entry left out from forprop.  For the heat conduction \problem, fluxes are the thermal fluxes conducting energy away or into elements.  A positive thermal \flux, say q12, means that element is losing heat at the rate q12 along side 1-2.  Relevant to Question \4 of 2009 Final Exam.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "Quad4IsoPPoissonFluxForces[ncoor_,mprop_,fprop_,forprop_,\n   opt_]:= \Module[{i,j,num=False,th=1,q, h,hm,\n      xi,xj,yi,yj,L, fe=Table[0,{4}]},\n \ If [Length[fprop]>0, th=fprop[[1]]];\n  If [Length[th]==0, h={th,th,th,th}, \h=th]; \n  If [Length[forprop]>1, q=forprop[[2]], Return[fe]];\n  If \[Length[opt]>0, num=opt[[1]]];\n  For [i=1, i<=Length[q], i++, If [i<4, \j=i+1, j=1];  \n       {xi,yi}=ncoor[[i]]; {xj,yj}=ncoor[[j]];\n       \L=PowerExpand[Sqrt[(xj-xi)^2+(yj-yi)^2]]; \n       hm=(h[[i]]+h[[j]])/2;\n    \   fe[[i]]-=hm*q[[i]]*L/2; fe[[j]]-=hm*q[[i]]*L/2;       \n      ]; \Return[Simplify[fe]]\n   ];\n\n",  StyleBox["ClearAll[a,b,k,h,h1,h2,h3,h4,q12,q23,q34,q41];\n\ncoor={{0,0},{a,0},{a,b},{0,b}};\n\fe=Quad4IsoPPoissonFluxForces[ncoor,{k},{{h1,h2,h3,h4}},\n  \{0,{q12,q23,q34,q41}},{False}];\nPrint[\"Flux over 4 sides, var h, fe=\",fe];\\nfe=Quad4IsoPPoissonFluxForces[ncoor,{k},{h},{0,{0,q23}},{False}];\n\Print[\"Flux over 2-3, const h, fe=\",fe];",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 6.  Assembly of master stiffness of Poisson problem as a full \symmetric matrix.  This moduleis similar to the assemblers for structural problems, with the simplification \that there is only oneDOF per node.  Hence the element nodelist (enl) and the element freedom table \(eftab) coalesce.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "MasterStiffnessPoisson[nodcoor_,eletyp_,elenod_,elemat_,\n  \elefab_,eleopt_]:=Module[\n  \{numele=Length[elenod],numnod=Length[nodcoor],neldof,e,enl,\n  \eftab,n1,n2,n3,n4,i,j,ncoor,mprop,fprop,opt,Ke,K},\n  \K=Table[0,{numnod},{numnod}];\n  For [e=1, e<=numele, e++,\n     \enl=elenod[[e]]; eftab={n1,n2,n3,n4}=enl; \n     \ncoor={nodcoor[[n1]],nodcoor[[n2]],\n            \nodcoor[[n3]],nodcoor[[n4]]};           \n     mprop=elemat[[e]]; \fprop=elefab[[e]]; opt=eleopt;  \n     \Ke=Quad4IsoPPoissonStiffness[ncoor,mprop,fprop,opt];\n     neldof=Length[Ke];\\n     For [i=1, i<=neldof, i++, ii=eftab[[i]];\n         For [j=i, \j<=neldof, j++, jj=eftab[[j]];\n             K[[jj,ii]]=K[[ii,jj]]+=Ke[[i,j]] \\n         ];\n       ];\n     ];\n  Return[K]\n  ];\n\n",  StyleBox["eletyp=Table[\"Quad4\",{2}]; (* eletyp is dummy placeholder *)\n\nodcoor={{0,1},{0,0},{2,1},{2,0},{4,1},{4,0}};\nelenod={{1,2,4,3},{3,4,6,5}}; \elemat={12,12}; elefab={1,1};     \n\K=MasterStiffnessPoisson[nodcoor,eletyp,elenod,elemat,elefab,{True} ];\n\Print[\"Master stiffness of Poisson FEM model:\"]; \nPrint[K//MatrixForm];\n\Print [\"eigs of K=\",Chop[Eigenvalues[K]]];",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 7.  Assembles the master node force vector of a Poisson  FEM \model.   This assembler goes element by element.  It gets consistent node forces dues to sources and \fluxes from theforce modules in Cells 4 and 5,  and merges those into the master force \vector.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "MasterNodeForcesPoisson[nodcoor_,eletyp_,elenod_,elemat_,\n   \elefab_,elefor_,eleopt_]:=Module[\n  \{numele=Length[elenod],numnod=Length[nodcoor],neldof,e,eNL,\n  \eftab,n1,n2,n3,n4,i,j,ncoor,mprop,fprop,forprop,opt,fe,f},\n  \f=Table[0,{numnod}];\n  For [e=1, e<=numele, e++,\n     eNL=elenod[[e]]; \eftab={n1,n2,n3,n4}=eNL; \n     ncoor={nodcoor[[n1]],nodcoor[[n2]],\n         \   nodcoor[[n3]],nodcoor[[n4]]};           \n     mprop=  elemat[[e]]; \fprop=elefab[[e]]; \n     forprop=elefor[[e]]; opt=eleopt;  \n     \fe=Quad4IsoPPoissonSourceForces[ncoor,mprop,fprop,\n          forprop,opt]+\n \       Quad4IsoPPoissonFluxForces  [ncoor,mprop,fprop,\n          \forprop,opt];\n     neldof=Length[fe];\n     For [i=1, i<=neldof, i++, \ii=eftab[[i]]; f[[ii]]+=fe[[i]] \n         ];\n     ];\n  Return[f]\n  ];\n  \\n",  StyleBox["ClearAll[s1,s2,q12,q24,q65];\neletyp=Table[\"Quad4\",{2}]; (* \eletyp is dummy placeholder *)\n\nodcoor={{0,4},{0,0},{3,4},{3,0},{4,4},{4,0}};\nelenod={{1,2,4,3},{3,4,6,5}}; \elemat={12,12}; elefab={1,1};\nelefor={{s1},{s2}};     \n\f=MasterNodeForcesPoisson[nodcoor,eletyp,elenod,\n         \elemat,elefab,elefor,{False} ];\nPrint[\"Master forces of Poisson model:\"]; \Print[f];\nelefor={{0,{q12,q24,0,0}},{0,{0,0,q65,0}}};     \n\f=MasterNodeForcesPoisson[nodcoor,elenod,\n         \elemat,elefab,elefor,{False} ];\nPrint[\"Master forces of Poisson model:\"]; \Print[f];",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 8.  Application of prescribed-dof boundary conditions.  These \modules are similar to those presented for structural problems, except that ModifiedNodeForces accounts \for prescribednonzero node values.  This is important for the heat conduction problem \because prescribednodal temperatures are generally nonzero.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "ModifiedMasterStiffness[pdof_,K_]:= Module[\n   {i,j,k,Kii,Kmod=K}, \n    \For [k=1, k<=Length[pdof], k++, i=pdof[[k]]; Kii=1;\n        For [j=1, \j<=Length[K], j++, \n            Kmod[[i,j]]=Kmod[[j,i]]=0]; Kmod[[i,i]]=Kii;\\n        ]; Return[Kmod]\n];\nModifiedNodeForces[pdof_,d_,K_,f_]:= Module[\n \ {i,j,k,l,m=Length[pdof],n=Length[K],fixed,fmod=f}, \n    \fixed=Table[False,{n}]; \n    For [k=1, k<=m, k++, i=pdof[[k]]; \fixed[[i]]=True];\n    For [k=1, k<=m, k++, i=pdof[[k]]; \n        For [j=1, \j<=n, j++, If [fixed[[j]],Continue[]];  \n             \fmod[[j]]-=K[[i,j]]*d[[k]]; \n            ]; fmod[[i]]=d[[k]]; \n        ]; \n\    Return[fmod];\n];\n  \n",  StyleBox["(* ClearAll[Ks,fs,d1,d2,d3];    \nK=Array[Ks,{6,6}];\n\Print[\"Master stiffness matrix:\"]; Print[K//MatrixForm];\nf=Array[fs,{6}];\n\Print[\"Master node force vector:\"]; Print[f];\n\f=ModifiedNodeForces[{1,2,4},{d1,d2,d3},K,f];\nPrint[\"Node force vector \modified for displacement B.C.:\"];\nPrint[f];\n\K=ModifiedMasterStiffness[{1,2,4},K];\nPrint[\"Stiffness matrix modified for \displacement B.C.:\"];\nPrint[K//MatrixForm]; *)",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 9A:  New mesh plotter Plot2DMesh, written Novembr 2009. \Fancier, faster andhigher quality than the old one but still barely debugged.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "Plot2DMesh[nodxyz_,eletyp_,elenod_,eleplt_,typdat_,\n   \nodpar_,elepar_,{drawframe_,drawnodes_,nodfill_,\n   \labelem_,labnodes_},aspect_,title_]:=Module[{i,j,k,n,m,\n  \numele=Length[elenod],numnod=Length[nodxyz],eletag,\n  \numobj,nodtag,ktypes,typtag,typhue,type,tk,e,enl,nen,\n  \etab,kelems,ke,pefill,pesid,pelab,pecirc,pedisk,\n  \epar=Length[elepar],npar=Length[nodpar],\n  \ecirad,ecirth,eshrink,efntsiz,efillhue,estyle,\n  \ncirad,ncirth,nlabofx,nlabofy,fntsiz,nfillhue,h,b,s,\n  \nstyle,knodes,pncirc,pnfill,pnlab,shrink,erad,\n  \idim,enlb,exy,exys,exybs,exy0,msg,nbn,n1,n2,nside,\n  \eginfo,nodcon,ncon,omitnodes=!drawnodes}, i=0;\n  eletag=Table[1,{numele}]; \numobj=Length[eleplt];  \n  If \[numobj>0,eletag=Plot2DTagObjects[numele,eleplt]];\n ",  StyleBox[" (*Print[\"eletag=\",eletag]; *)",    FontColor->RGBColor[1, 0, 0]],  " \n  {ecirad,ecirth,eshrink,efntsiz,efillhue}=\n      \{8,1.5,1,12,{0.15,1,1}}; ",  StyleBox["\n",    FontColor->RGBColor[0, 0, 1]],  "  If [epar==1,{ecirad}=elepar];    \n  If \[epar==2,{ecirad,ecirth}=elepar];  \n  If \[epar==3,{ecirad,ecirth,eshrink}=elepar];   \n  If \[epar==4,{ecirad,ecirth,eshrink,efntsiz}=elepar];  \n  If \[epar==5,{ecirad,ecirth,eshrink,efntsiz,efillhue}=elepar];\n",  StyleBox["  (*Print[\"ecirad,ecirth,eshrink,efntsiz,efillhue=\",\n        \{ecirad,ecirth,eshrink,efntsiz,efillhue}];*)\n ",    FontColor->RGBColor[1, 0, 0]],  " shrink=!(eshrink==1||eshrink==1.0); \n  \estyle=TextStyle->{FontFamily->\"Times\",FontSize->efntsiz,\n         \FontWeight->\"Plain\",FontSlant->\"Plain\"};\n  ktypes=Length[typdat]; \typtag={\"All\"}; typhue={efillhue};\n  If [ktypes>0, typtag=Table[\" \\",{ktypes}];\n      typhue=Table[efillhue,{ktypes}];\n    ",  StyleBox["  (*Print[\"initial typtag=\",typtag,\"\\ninitial \typhue=\",typhue];*)",    FontColor->RGBColor[1, 0, 0]],  "\n      For [k=1,k<=ktypes,k++, tk=typdat[[k]]; \n           If \[Length[tk]==0,typtag[[k]]=tk];\n           If \[Length[tk]>=1,typtag[[k]]=tk[[1]]];\n           If \[Length[tk]>=2,typhue[[k]]=tk[[2]]]];\n      For [e=1,e<=numele,e++,\n        \   etag=eletag[[e]]; If [etag==0,Continue[]];       \n           \If[!MemberQ[typtag,eletyp[[e]]],eletag[[e]]=0];\n           ];\n     ];\n",  StyleBox["  (*Print[\"typtag and hue=\",{typtag,typhue}//MatrixForm];\n  \Print[\"eletag after typtag=\",eletag];*)\n  ",    FontColor->RGBColor[1, 0, 0]],  "kelems=Sum[eletag[[i]],{i,numele}]; \n  If [kelems<=0, Print[\"Plot2DMesh: \empty plot\"]; Return[]]; \n  \pefill=peside=pecirc=pedisk=pelab=Table[{},{kelems}];  \n  If \[!labelems,pefill=pecirc=pelab={}];\n  nodtag=Table[0,{numnod}];\n  For \[e=1,e<=numele,e++, If [eletag[[e]]==0,Continue[]];\n     enl=elenod[[e]];    \    \n     For [i=1,i<=Length[enl],i++, n=enl[[i]]; \n          If \[shrink,nodtag[[n]]+=1,nodtag[[n]]=1]];\n          ];\n  \knodes=Sum[nodtag[[i]],{i,numnod}];\n",  StyleBox["  (*Print[\"knodes=\",knodes];*)",    FontColor->RGBColor[1, 0, 0]],  "\n  If [knodes>0,pncirc=pnfill=pnlab=Table[{},{knodes}]];  \n  If \[omitnodes,pncirc=pnfill=pnlab={}];  \n  If [!labnodes,pnlab={}];\n      \{ncirad,ncirth,nlabofx,nlabofy,nfntsiz,nfillhue}=\n      \{3,1.5,-8,5,12,{0.7,0.2,0.9}};\n",  StyleBox[" (*Print[\"ncirad,ncirth,nlabofx,nlabofy,nfntsiz,nfillhue=\",\n   \     {ncirad,ncirth,nlabofx,nlabofy,nfntsiz,nfillhue}];*)",    FontColor->RGBColor[1, 0, 0]],  "\n  If [npar==1,{ncirad}=nodpar];    \n  If \[npar==2,{ncirad,ncirth}=nodpar];  \n  If \[npar==3,{ncirad,ncirth,nlabofx}=nodpar];   \n  If \[npar==4,{ncirad,ncirth,nlabofx,nlabofy}=nodpar];  \n  If \[npar==5,{ncirad,ncirth,nlabofx,nlabofy,nfntsiz}=nodpar];  \n  If \[npar==6,{ncirad,ncirth,nlabofx,nlabofy,nfntsiz,nfillhue}=nodpar];\n  \nstyle=TextStyle->{FontFamily->\"Times\",FontSize->nfntsiz,\n                 \    FontWeight->\"Plain\",FontSlant->\"Plain\"};\n  {h,s,b}=nfillhue; \nodcon=Table[{},{numnod}];  \n  lastyp=\"All\";  k=0;\n  For \[e=1,e<=numele,e++, If [eletag[[e]]==0,Continue[]]; k++;\n       \type=eletyp[[e]]; enl=elenod[[e]]; nen=Lenghth[enl]; \n      \{idim,enlb,exy,exys,exybs,exy0,msg}=Plot2DElemGeoInfo[\n       \type,nodxyz,enl,eshrink];\n",  StyleBox["       (*Print[\"idim,enlb,exys,exybs,exy0=\",\n        \{idim,enlb,exys,exybs,exy0},\" msg=\",msg]; *)",    FontColor->RGBColor[1, 0, 0]],  "\n       If [msg!=\" \", Print[\"Plot2DMesh: \",msg,\", at elem \",e,\n    \       \"  Plot skipped\"]; Return[]]; nbn=Length[enlb];\n       \eginfo={idim,enlb,exy,exys,exybs,exy0,ecirad,\n               \labelem,estyle,shrink};      \n      \{gefill,geside,gedisk,gecirc,gelab}=Plot2DIndElement[\n              \e,type,eginfo,nodcon];\n       If [lastyp!=type, kk=Position[typtag,type]; \n \      ",  StyleBox["    (*Print[\"lastyp,=\",lastyp,\" type=\",type,\" kk=\",kk];*)",    FontColor->RGBColor[1, 0, 0]],  "\n           If [kk=={}, kt=0; {h,s,b}=efillhue, \n                      \{{kt}}=kk; {h,s,b}=typhue[[kt]]];\n           \gefill={Graphics[Hue[h,s,b]],gefill};\n           lastyp=type];\n      \{pefill[[k]],peside[[k]],pedisk[[k]],pecirc[[k]],\n       \pelab[[k]]}={gefill,geside,gedisk,gecirc,gelab};       \n       If [!shrink,\n\           For [i=1,i<=nbn,i++, j=i+1; If [i==nbn,j=1];\n                \nside={enlb[[i]],enlb[[j]]};               \n                n1=Min[nside]; \n2=Max[nside]; ncon=nodcon[[n1]];               \n                If \[MemberQ[ncon,n2], Continue[]];\n                AppendTo[ncon,n2]; \nodcon[[n1]]=Sort[ncon]]; \n           ];\n      ];  ",  StyleBox["(*Print[\"final nodcon=\",nodcon]; *)",    FontColor->RGBColor[1, 0, 0]],  "\n      \n   If [drawnodes,      \n      If [!shrink,\n          \{pncirc,pnfill,pnlab}=Plot2DNonShrunkNodes[nodxyz,nodtag,\n          \{ncirad,ncirth,nlabofx,nlabofy,nfntsiz},{nodfill,labnodes}];\n         ];     \ \n      If [shrink,\n          {pncirc,pnfill,pnlab,msg}=Plot2DShrunkNodes[\n\          nodxyz,nodtag,{ncirad,ncirth,nlabofx,nlabofy,nfntsiz},\n          \{nodfill,labnodes},eletyp,elenod,eletag,eshrink];\n          If [msg!=\" \\",Return[]]\n         ];         \n     ];   \n  {h,s,b}=efillhue;          \\n  Show[Graphics[Hue[h,s,b]],pefill,\n       \Graphics[Hue[0,0,0]],Graphics[AbsoluteThickness[1.5]],\n       \peside,Graphics[GrayLevel[1]],pedisk,\n       \Graphics[GrayLevel[0]],pecirc,pelab,\n       Graphics[RGBColor[0,0,0]],\n     \  Graphics[AbsoluteThickness[1.5]],\n       Graphics[GrayLevel[.7]],\n       \pnfill,Graphics[GrayLevel[0]],pncirc,pnlab,\n       \PlotRegion->{{0,1},{0,1}},\n       Background->GrayLevel[.95],\n       \PlotLabel->title,AspectRatio->aspect,\n       \Frame->drawframe,DisplayFunction->DisplayChannel ];\n   \ClearAll[eletag,nodtag,nodcon,pefill,pesid,\n        pncirc,pedisk,pnlab];\n\];\n\nPlot2DTagObjects[numobj_,objplt_]:=Module[{i,j,\n  \k,l,m,n,obj,h,objtag=Table[0,{numobj}]},\n  For [m=1,m<=Length[objplt],m++, \n\       obj=objplt[[m]]; l=Length[obj]; h=Head[obj];\n       If [h==Integer, \n=obj; \n          If [n>0&&n<=numobj, objtag[[n]]=1]];\n       If \[h==List&&l==1, {n}=obj; \n          If [n>0&&n<=numobj, objtag[[n]]=1]];\n   \    If [h==List&&l==2, {i,j}=obj; \n          For \[n=Min[i,j],n<=Max[i,j],n++, \n          If [n>0&&n<=numobj, \objtag[[n]]=1]]];\n       If [h==List&&l==3, {i,j,k}=obj; k=Abs[k]; \n        \  For [n=Min[i,j],n<=Max[i,j],n+=k, \n          If [n>0&&n<=numobj, \objtag[[n]]=1]]];\n       ]; Return[objtag]];\n       \n          \n\Plot2DElemGeoInfo[type_,nodxyz_,enl_,eshrink_]:=Module[\n  \{i,k,kp,m1,m2,typedot=type<>\".\",name,idim=0,bn,nbn,\n   enamtab={\"Bar2\",  \1,2,{1,2},\n            \"Bar3\",  1,3,{1,3,2}, \n            \"Trig3\", \2,3,{1,2,3},\n            \"Trig4\", 2,4,{1,4,2,3},  \n            \"Trig5\", \2,5,{1,4,2,6,3}, \n            \"Trig6\", 2,6,{1,4,2,5,3,6},\n            \\"Trig9\", 2,9,{1,4,5,2,6,7,3,8,9},\n            \\"Trig10\",2,10,{1,4,5,2,6,7,3,8,9},\n            \"Quad4\", 2,4,{1,2,3,4}, \n\            \"Quad8\", 2,8,{1,5,2,6,3,7,4,8},\n            \"Quad9\", \2,9,{1,5,2,6,3,7,4,8},\n            \\"Quad12\",2,12,{1,5,6,2,7,8,3,9,10,4,11,12},\n            \\"Quad16\",2,16,{1,5,6,2,7,8,3,9,10,4,11,12}},\n   \nen,nenl,enlb,exy,exys,exyb,exybs,exy0,exy0s}, \n   enlb=exyb=exybs=exy0={}; \\n   {{m1,m2}}=StringPosition[typedot,\".\",1]; \n   \name=StringTake[type,m1-1]; k=Position[enamtab,name]; \n   If \[k=={},kp=0,{{kp}}=k]; \n   If [kp==0, Return[{0,0,0,0,0,0,\"Illegal elem \type \"<>type}]];\n   {idim,nen,bn}=Take[enamtab,{kp+1,kp+3}]; \nbn=Length[bn];\n  ",  StyleBox[" (*Print[\"type=\",type,\" k=\",k,\" \idim,nen,bn=\",{idim,nen,bn}];*)",    FontColor->RGBColor[1, 0, 0]],  "\n   nbn=Length[bn]; nenl=Length[enl]; \n   If [nbn<=0, \Return[{0,0,0,0,0,0,\"No boundary nodes\"}]];\n   If [nen!=neln, \Return[{0,0,0,0,0,0,\"Incorrect nodelist\"}]];\n   \enlb=Table[enl[[bn[[i]]]],{i,nbn}];\n   exy \=Table[Take[nodxyz[[enl[[i]]]],2],{i,nen}]; \n   \exyb=Table[exy[[bn[[i]]]],{i,nbn}];\n   exy0=Sum[exyb[[i]],{i,nbn}]/nbn;\n   \If [eshrink==1||eshrink==1.0,\n       Return[{idim,enlb,exy,exy,exyb,exy0,\" \\"}]];\n   exy0s=(1-eshrink)*exy0;\n   exys= Table[exy0s+eshrink*exy \[[i]],{i,nen}];\n   exybs=Table[exys[[bn[[i]]]],{i,nbn}];\n   \Return[{idim,enlb,exy,exys,exybs,exy0,\" \"}]];\n   \n       \n\Plot2DNonShrunkNodes[nodxyz_,nodtag_,npars_,nflags_]:=\n   \Module[{n,k=0,numnod=Length[nodxyz],\n   \ncirad,ncirth,nlabofx,nlabofy,nfntsiz,\n   nodfill,labnodes,knodes,x,y,\n   \xytext,rnod,nlab,style,pncirc,pnfill,pnlab},\n  \{ncirad,ncirth,nlabofx,nlabofy,nfntsiz}=npars;\n  {nodfill,labnodes}=nflags;\n\   knodes=Sum[nodtag[[i]],{i,numnod}];\n   \pncirc=pnfill=pnlab=Table[{},{knodes}]; \n   If [!nodfill,pnfill={}]; If \[!labnodes,pnlab={}];\n   \style=TextStyle->{FontFamily->\"Times\",FontSize->nfntsiz,\n                  \   FontWeight->\"Plain\",FontSlant->\"Plain\"};",  StyleBox[" ",    FontColor->RGBColor[0, 0, 1]],  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n   For [n=1,n<=numnod,n++, If [nodtag[[n]]==0, Continue[]]; \n       \k++; {x,y}=Take[nodxyz[[n]],2];\n       rnod=  Offset[N[{ncirad,ncirad}]];\n  \     pncirc[[k]]= Graphics[Circle[{x,y},rnod]];\n       If [nodfill, \pnfill[[k]]=Graphics[Disk[{x,y},rnod]]];\n       If [labnodes, \nlab=ToString[n]; \n           xytext=Offset[N[{nlabofx,nlabofy}],{x,y}];\n   \        pnlab[[k]]=Graphics[Text[nlab,xytext,style]]];\n      ];\n   \Return[{pncirc,pnfill,pnlab}]];\n\n\Plot2DShrunkNodes[nodxyz_,nodtag_,npars_,nflags_,\n   \eletyp_,elenod_,eletag_,eshrink_]:=Module[{e,n,i,\n   \numnod=Length[nodxyz],numele=Length[elenod],k=0,klab=0,\n   \ncirad,ncirth,nlabofx,nlabofy,nfntsiz,nodfill,labnodes,\n   \knodes,knlabs,labtag,type,enl,nen,enlb,exyb,exy0,x,y,\n   \xs,ys,exy,exys,xytext,rnod,nlab,style,pncirc,pnfill,pnlab},\n  \{ncirad,ncirth,nlabofx,nlabofy,nfntsiz}=npars;\n  {nodfill,labnodes}=nflags; \\n   If [labnodes, worig=4;\n       nlabxy=worig*nodxyz; \nlabct=Table[worig,{numnod}];\n       For [e=1,e<=numele,e++, If \[eletag[[e]]==0,Continue[]];\n           enl=elenod[[e]]; nen=Length[enl]; \type=eletyp[[e]];\n          \{idim,enlb,exy,exys,exybs,exy0,msg}=Plot2DElemGeoInfo[\n          \type,nodxyz,enl,eshrink]; If [msg!=\" \",Continue[]];\n           For \[i=1,i<=nen,i++, n=enl[[i]];\n                nlabxy[[n]]+=exys[[i]]; \nlabct[[n]]+=1] ];\n      ]; \n",  StyleBox["   (* For [n=1,n<=numnod,n++,nlabxy[[n]]/=nlabct[[n]]];*)\n   (* \Print[\"nlabxy=\",nlabxy]; Print[\"nlabct=\",nlabct];*)",    FontColor->RGBColor[1, 0, 0]],  "\n   knodes=Sum[nodtag[[i]],{i,numnod}];\n   \knlabs=Sum[Min[nodtag[[i]],1],{i,numnod}];\n   labtag=Table[1,{numnod}];\n   \pncirc=pnfill=Table[{},{knodes}]; pnlab=Table[{},{knlabs}];  \n   If \[!nodfill,pnfill={}]; If [!labnodes,pnlab={}];\n   \style=TextStyle->{FontFamily->\"Times\",FontSize->nfntsiz,\n                  \   FontWeight->\"Plain\",FontSlant->\"Plain\"};                  \n   For \[e=1,e<=numele,e++, If [eletag[[e]]==0,Continue[]]; \n       enl=elenod[[e]]; \nen=Length[enl]; type=eletyp[[e]];\n      \{idim,enlb,exy,exys,exybs,exy0,msg}=Plot2DElemGeoInfo[\n               \type,nodxyz,enl,eshrink];\n",  StyleBox["      (*Print[{e,type,nodxyz,enl,eshrink},\n             \{idim,enlb,exy,exys,exybs,exy0,msg}];*)",    FontColor->RGBColor[1, 0, 0]],  "\n      If [msg!=\" \", Print [\"Plot2DShrunkNodes: \", msg,\" elem \",e,\n\              \" Plot skipped\"]; \n            \Return[{pncirc,pnfill,pnlab,msg}]];",  StyleBox["          ", "Text"],  StyleBox[" ", "Text",    FontColor->RGBColor[0, 0, 1]],  StyleBox[" ", "Text",    FontColor->RGBColor[1, 0, 0]],  StyleBox["\n       For [i=1,i<=nen,i++, n=enl[[i]];\n            If \[nodtag[[n]]==0, Continue[]]; ", "Text"],  "\n            k++; {xs,ys}=exys[[i]]; {x,y}=exy[[i]];\n            rnod=  \Offset[N[{ncirad,ncirad}]];\n            pncirc[[k]]= \Graphics[Circle[{xs,ys},rnod]];\n            If [nodfill, \pnfill[[k]]=Graphics[Disk[{xs,ys},rnod]]];\n            If \[labnodes&&labtag[[n]]>0, klab++;\n                \{x,y}=nlabxy[[n]]/nlabct[[n]]; nlab=ToString[n]; \n                \xytext=Offset[N[{0,0}],{x,y}]; labtag[[n]]=0;\n                \pnlab[[klab]]=Graphics[Text[nlab,xytext,style]]];\n           ]; \n       ]; \ClearAll[labtag,nlabxy,nlabct]; \n   Return[{pncirc,pnfill,pnlab,\" \"}]];\n  \ \nPlot2DIndElement[e_,type_,eginfo_,nodcon_]:=Module[{i,j,nbn,\n  \nen,n1,n2,nside,side,idim,enlb,exy,exys,exybs,exy0,elab,\n  \erad,xytext,epoly,dx,dy,LL,L,c,s,d=0.1,\n  \gepoly={},geside={},gedisk={},gecirc={},gelab={}},\n  \{idim,enlb,exy,exys,exybs,exy0,ecirad,\n   labelem,estyle,shrink}=eginfo;\n",  StyleBox["  (* Print[\"Plot2DIndElement: \",{idim,enlb,exy,exys,\n          \ exybs,exy0,ecirad,labelem,estyle,shrink}];\n   Print[\"entry nodcon: \\",nodcon];*)",    FontColor->RGBColor[1, 0, 0]],  "\n   nbn=Length[enlb];  erad=Offset[N[{ecirad,ecirad}]]; \n   If [idim==2, \gefill=Graphics[Polygon[exybs]];\n       For [i=1,i<=nbn,i++, j=i+1; If \[i==nbn,j=1]; \n            nside={enlb[[i]],enlb[[j]]}; \side={exybs[[i]],exybs[[j]]};\n            n1=Min[nside]; n2=Max[nside];\n    \        If [shrink, epoly=Flatten[{exybs,{exybs[[1]]}},1];\n                \geside=Graphics[Line[epoly]]];",  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n            If [!shrink&&!MemberQ[nodcon[[n1]],n2],\n      ",  StyleBox["          (*Print[\"Plotting side \",n1,\" to \",n2];*)",    FontColor->RGBColor[1, 0, 0]],  "\n                AppendTo[geside,Graphics[Line[side]]] ]; \n            \];\n       ];\n   If [idim==1,\n       If [shrink, \{dx,dy}=exybs[[2]]-exybs[[1]];\n       LL=dx^2+dy^2; {c,s}={1,0}; If \[LL>0,L=Sqrt[LL];c=dy/L;s=-dx/L];\n      ",  StyleBox[" (*Print[\"c=\",c,\" s=\",s,\" L=\",L];*) ",    FontColor->RGBColor[1, 0, 0]],  StyleBox[" d=0.01*L;",    FontColor->RGBColor[0, 0, 1]],  "\n       epoly={exys[[1]]+{ d*c, d*s},exys[[2]]+{ d*c, d*s},\n             \ exys[[2]]+{-d*c,-d*s},exys[[1]]+{-d*c,-d*s},\n              exys[[1]]+{ d*c, \d*s}};\n       geside=Graphics[Line[epoly]]];\n       \gefill={Graphics[Hue[0,0,0]],\n               Graphics[Polygon[epoly]]}];\n   \If [labelem, gedisk=Graphics[Disk[exy0,erad]]];\n       \gecirc=Graphics[Circle[exy0,erad]];\n       elab=ToString[e]; \xytext=Offset[N[{0,-1}],exy0];\n       gelab= \Graphics[Text[elab,xytext,estyle]];\n   \Return[{gefill,geside,gedisk,gecirc,gelab}]];\n   \n\Plot2DNodes[nodxyz_,nodplt_,nodpar_,{drawframe_,nodfill_,\n      \labnodes_},aspect_,title_]:= Module[{n,k,\n  \numnod=Length[nodxyz],npar=Length[nodpar],nodtag,\n  \ncirad,ncirth,nlabofx,nlabofy,nfntsiz,nfillhue,\n  \numobj,x,y,h,s,b,knodes,pnfill,pncirc,pnlab},\n  nodtag=Table[1,{numnod}]; \numobj=Length[nodplt];\n  If [numobj>0, \nodtag=Plot2DTagObjects[numnod,nodplt]]; \n",  StyleBox["  (*Print[\"nodtag=\",nodtag];*)",    FontColor->RGBColor[1, 0, 0]],  "\n  knodes=Sum[nodtag[[i]],{i,numnod}];",  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n  If [knodes<=0, Print[\"Plot2DNodes: empty plot\"]; Return[]];\n  \{ncirad,ncirth,nlabofx,nlabofy,fntsiz,nfillhue}=\n      \{3,1.5,-8,5,12,{0.7,0.2,0.9}};\n  If [npar==1,{ncirad}=nodpar];  \n  If \[npar==2,{ncirad,ncirth}=nodpar];\n  If \[npar==3,{ncirad,ncirth,nlabofx}=nodpar]; \n  If \[npar==4,{ncirad,ncirth,nlabofx,nlabofy}=nodpar];\n  If \[npar==5,{ncirad,ncirth,nlabofx,nlabofy,nfntsiz}=nodpar];\n  If \[npar==6,{ncirad,ncirth,nlabofx,nlabofy,nfntsiz,\n               \nfillhue}=nodpar];\n",  StyleBox["  (*Print[\"npar=\",npar]; Print[nodpar];\n  \Print[{ncirad,ncirth,nlabofx,nlabofy,nfntsiz,nfillhue}];*) ",    FontColor->RGBColor[1, 0, 0]],  "\n {h,s,b}=nfillhue;  k=0; ",  StyleBox["\n ",    FontColor->RGBColor[1, 0, 0]],  "{pncirc,pnfill,pnlab}=Plot2DNonShrunkNodes[nodxyz,nodtag,\n                \     {ncirad,ncirth,nlabofx,nlabofy,nfntsiz},\n                     \{nodfill,labnodes}];\n  \Show[Graphics[RGBColor[0,0,0]],Graphics[Hue[h,s,b]],pnfill,\n       \Graphics[RGBColor[0,0,0]],Graphics[AbsoluteThickness[ncirth]],\n       \pncirc,pnlab,AspectRatio->aspect,PlotLabel->title,\n       \Frame->drawframe,DisplayFunction->DisplayChannel ];\n  \ClearAll[nodtag,pncirc,pnfill,pnlab]; \n  ]; \n\n\n",  StyleBox["nodxyz=N[{{0,10},{-8.66,5},{-8.66,-5},{0,-10},{8.66,-5},{8.66,5},\\n        {-4.33,2.5},{-4.33,-2.5},{4.33,-2.5},{4.33,2.5},{0,0}}];\n\elenod={{1,2,7},{2,3,8,7},{3,4,8},{1,7,11},{7,8,11},{8,4,11},\n        \{1,11,10},{11,9,10},{11,4,9},{1,10,6},{10,9,5,6},{4,5,9},\n       \{1,7},{7,8},{8,4}}; \nelepar={9,1.5,.85,12,{0.15,1,1}};\n\nodpar={4,1.5,-8,5,12,{0.7,0.2,0.9}}; \naspect=8.66/10;  aspect=1;\n\eletyp={\"Trig3\",\"Quad4\",\"Trig3\",\"Trig3\",\"Trig3\",\"Trig3\",\n        \\"Trig3\",\"Trig3\",\"Trig3\",\"Trig3\",\"Quad4\",\"Trig3\",\"Bar2\",\"Bar2\",\\"Bar2\"};\n        elepar={9,1.5,1,12,{0.15,1,1}};\n\typspec={{\"Trig3\"},{\"Quad4\"}}; elepar={9,1.5,1,12,{0.15,1,1}};\n\Plot2DMesh[nodxyz,eletyp,elenod,{{1,15}},typspec,\n\nodpar,elepar,{True,True,True,True,True},aspect,\" \"];\n\elepar={9,1.5,.85,12,{0.15,1,1}};\n\typspec={\"Bar2\",{\"Trig3\",{1/2,1,1}},{\"Quad4\",{0,1,1}}}; \n\Plot2DMesh[nodxyz,eletyp,elenod,{{1,15}},typspec,\n  \nodpar,elepar,{True,True,True,True,True},aspect,\" \"];",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 9B. This cell contains the contour plotter \ContourPlotNodeFuncOver2DMesh.Mathematica version written 1997, adapting very old Fortran code (first \version usedfor Berkeley FEM thesis, 1966).  Based on subdividing element regions into \polygons, with mean-value - > polygon-color mapping based on a red-white-blue \interpolation on a subset of RGBColor.  Function assumed C0 interelem continuous. A well \debugged workhorse.  Big deficiency: plots are not publication quality unless Nsub is \increased substantially, but plot time goes up as the square of Nsub, so it can become \intolerably slow.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell["\<\ContourPlotNodeFuncOver2DMesh[xycoor_,elenod_,f_,fmax_,Nsub_,  aspect_,label_]:= Module[{eNL,i,j,k,n,nc,xyc,fc,xyc9,fc9,  s9={{1,5,9,8},{2,6,9,5},{3,7,9,6},{4,8,9,7}},s,  numele=Length[elenod],p,poly={}}, For [ne=1, ne<=numele, ne++,    eNL=elenod[[ne]]; nc=Length[eNL];     If [nc!=3 && nc!=4 &&nc!=9, Continue[]];    fc=xyc=Table[0,{nc}];     Do [n=eNL[[i]]; xyc[[i]]=xycoor[[n]];         fc[[i]]=f[[n]], {i,1,nc}];    (*Print[\"ne=\",ne,\"  nc=\",nc,\" fc=\",fc];*)      If [nc==3,p=PlotFunctionOverTrig[xyc,fc,fmax,Nsub];        poly=Join[poly,p]];    If [nc==4,p=PlotFunctionOverQuad[xyc,fc,fmax,Nsub];        poly=Join[poly,p]];    If [nc==9,         Do [s=s9[[i]]; xyc9=fc9={0,0,0,0};            Do[ k=s[[j]]; xyc9[[j]]=xyc[[k]];               fc9[[j]]=fc[[k]],{j,1,4}];        p=PlotFunctionOverQuad[xyc9,fc9,fmax,Nsub];        poly=Join[poly,p], {i,1,4}] ];     ]; Show[poly, AspectRatio->aspect, PlotLabel->label,      DisplayFunction->DisplayChannel];];ContourPlotElemFuncOver2DMesh[xycoor_,elenod_,fe_,fmax_, Nsub_,aspect_,label_]:= Module[{eNL,n,nc,xyc,fc,poly={},p}, For[ ne=1, ne<=Length[elenod], ne++,    eNL=elenod[[ne]]; nc=Length[eNL];     If [nc!=3 && nc!=4, Continue[]];    fc=xyc=Table[fe[[ne]],{nc}];     Do [n=eNL[[i]]; xyc[[i]]=xycoor[[n]], {i,1,nc}];     (* Print[{ne,xyc,fc}]; *)    If [nc==3,p=PlotFunctionOverTrig[xyc,fc,fmax,1]];    If [nc==4,p=PlotFunctionOverQuad[xyc,fc,fmax,1]];    poly=Join[poly,p] ]; Show[poly, AspectRatio->aspect, PlotLabel->label, DisplayFunction->DisplayChannel];];PlotFunctionOverTrig[xyc_,fc_,fmax_,Nsub_]:=Module[   {Ni,zc1,zc2,zc3,xc,yc, x1,x2,x3,y1,y2,y3,    iz1,iz2,iz3,c1,c2,c3,d,f1,f2,f3,f,poly={}},   {{x1,y1},{x2,y2},{x3,y3}}=xyc;     xc={x1,x2,x3}; yc={y1,y2,y3}; {f1,f2,f3}=fc; Ni=Nsub*3;    Do [ Do [iz3=Ni-iz1-iz2; If [iz3<=0, Continue[]]; d=0;\t\t\t If [Mod[iz1+2,3]==0&&Mod[iz2-1,3]==0, d=  1];\t\t\t If [Mod[iz1-2,3]==0&&Mod[iz2+1,3]==0, d= -1];\t\t\t If [d==0, Continue[]];\t\t\t zc1=N[{iz1+d+d,iz2-d,iz3-d}/Ni];\t\t\t zc2=N[{iz1-d,iz2+d+d,iz3-d}/Ni];\t\t\t zc3=N[{iz1-d,iz2-d,iz3+d+d}/Ni];\t\t\t f=N[(f1*iz1+f2*iz2+f3*iz3)/Ni]; \t\t\t {c1,c2,c3}=ContourPolyColor[f,fmax];\t\t     AppendTo[poly,Graphics[RGBColor[c1,c2,c3]]];\t\t     AppendTo[poly,Graphics[Polygon[{{xc.zc1,yc.zc1},\t\t     {xc.zc2,yc.zc2},{xc.zc3,yc.zc3}}]]],   \t{iz2,1,Ni-iz1}],{iz1,1,Ni}];   \tReturn[poly];\t];\tPlotFunctionOverQuad[xyc_,fc_,fmax_,Nsub_]:=Module[    {Ne,Nev,xy1,xy2,xy3,i,j,n,ixi,ieta,xi,eta,x1,x2,x3,x4,     y1,y2,y3,y4,xc,yc,c1,c2,c3,d,f1,f2,f3,f4,f,poly={}},\t\t{{x1,y1},{x2,y2},{x3,y3},{x4,y4}}=xyc;\t\t xc={x1,x2,x3,x4}; yc={y1,y2,y3,y4};{f1,f2,f3,f4}=fc;\t\t Ne[xi_,eta_]:=N[{(1-xi)*(1-eta),(1+xi)*(1-eta),\t\t\t\t\t               (1+xi)*(1+eta),(1-xi)*(1+eta)}/4]; \t n=Nsub;   Do [ Do [ ixi=(2*i-n-1)/n; ieta=(2*j-n-1)/n;\t\t\t   {xi,eta}=N[{ixi-1/n,ieta-1/n}];Nev=Ne[xi,eta];      xy1={xc.Nev,yc.Nev};\t\t\t   {xi,eta}=N[{ixi+1/n,ieta-1/n}];Nev=Ne[xi,eta];\t\t\t   xy2={xc.Nev,yc.Nev};\t\t\t   {xi,eta}=N[{ixi+1/n,ieta+1/n}];Nev=Ne[xi,eta];\t\t\t   xy3={xc.Nev,yc.Nev};\t\t\t   {xi,eta}=N[{ixi-1/n,ieta+1/n}];Nev=Ne[xi,eta];\t\t\t   xy4={xc.Nev,yc.Nev};\t\t\t   Nev=Ne[N[ixi],N[ieta]]; \t\t\t  {c1,c2,c3}=ContourPolyColor[fc.Nev,fmax];\t\t    AppendTo[poly,Graphics[RGBColor[c1,c2,c3]]];\t\t    AppendTo[poly,Graphics[Polygon[{xy1,xy2,xy3,xy4}]]],   \t{i,1,Nsub}],{j,1,Nsub}];    Return[poly];\t];\tContourPolyColor[f_,fmax_]:= Module[{r,RGBmax={1,0,0},     RGBmin={0,0,1}, RGBzero={1,1,1}, RGBout={0,0,0}},   If [f==0 || fmax==0,          Return[RGBzero]];  (* White if f=0 *)   If [f>fmax || f<-fmax,        Return[RGBout ]];  (* Black if outside range *)   If [f>0, r= N[f/fmax];        Return[r*RGBmax+(1-r)*RGBzero]]; (* positive *)   If [f<0, r=-N[f/fmax];        Return[r*RGBmin+(1-r)*RGBzero]]; (* negative *)];\\>", "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 9C. A new \"contour band\" plot module written summer 2008 is \provided in this cell.  The entry module is ContourBandPlotNodeFuncOver2DMesh.  This differs from ContourPlotNodeFuncOver2DMesh in being band-region based raher thanpolygonal based. The band-value -> band-color map is based on Hue rather than RGBColor so it can display the full \"rainbow\". It is faster (scales \linearly innumber of bands) and can produce publication quality plots. The downside is \that it has  been used only for a few months so bugs may be still lurking.  \\>", \"Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "ContourBandPlotNodeFuncOver2DMesh[nodxyz_,elenod_,fn_,{fmin_,fmax_,finc_},\\n  {colors_,mesh_,nodes_,bacg_,lines_,bound_},xyleg_,aspect_,label_]:= \Module[\n  \{enl,i,k,n,ne,xyc,fc,c,nn,pb,pl,eps,prebacg,pbacg,preband,pband,preline,\n  \bnt,bn,nbn,enb,xyb,bseg,ebs,seg,rseg,nbseg,prebound,pbound,\n  \pline,premesh,pmesh,prenode,preleg,pleg,pnode,numele=Length[elenod]},\n  \bnt={{},{},{1,2,3,1},{1,2,3,4,1},{},{1,4,2,5,3,6,1},\n      \{},{1,5,2,6,3,7,4,8,1},{1,5,2,6,3,7,4,8,1},\n      \{1,4,5,2,6,7,3,8,9,1},{},{},{},{},{},{1,5,6,2,7,8,3,9,10,4,11,12,1}}; \n  \eps=10.^(-8)*Max[Abs[fmax],Abs[fmin]]; pband=pmesh=pnode=pline=pbacg={}; \n  \If [colors,pband=Table[{},{numele}]]; If [mesh, pmesh=Table[{},{numele}]]; \n \ If [nodes, pnode=Table[{},{numele}]]; If [lines,pline=Table[{},{numele}]]; \n\  If [bacg,  pbacg=Table[{},{numele}]]; preleg=pleg=bseg=pbound={};\n  \prebacg= {Graphics[RGBColor[.7,.7,.7]]}; preband={};\n  preline= \{Graphics[RGBColor[0,0,0]],Graphics[AbsoluteThickness[1]]};\n  premesh= \{Graphics[RGBColor[1,0,0]],Graphics[AbsoluteThickness[2]],\n            \Graphics[AbsoluteDashing[{1,10}]]};\n  prenode= \{Graphics[RGBColor[0,0,0]],Graphics[AbsoluteDashing[{}]],\n            \Graphics[AbsolutePointSize[5]]};\n  \prebound={Graphics[RGBColor[0,0,1]],Graphics[AbsoluteDashing[{}]],\n          \  Graphics[AbsoluteThickness[2]]};\n  For [e=1,e<=Length[elenod],e++, \n      \enl=elenod[[e]]; ne=Length[enl];  \n      If [!MemberQ[{3,4,6,8,9,10,16},ne], \Print[\"ContourBandPlot:\",\n           \"Elem \",e,\" with \",ne,\" nodes \skipped\"]; Continue[]];\n      fc=Table[fn[[enl[[i]]]],{i,ne}]; \xyc=Table[nodxyz[[enl[[i]]]],{i,ne}];\n      bn=bnt[[ne]];  nbn=Length[bn]; \xyb=Table[xyc[[bn[[i]]]],{i,nbn}];\n      If [bound, \enb=Table[enl[[bn[[i]]]],{i,nbn}]; \n          \ebs=Table[{enb[[i]],enb[[i+1]]},{i,1,nbn-1}]; ",  StyleBox["\n",    FontColor->RGBColor[1, 0, 0]],  "          For [i=1,i<=nbn-1,i++, seg=ebs[[i]]; rseg=Reverse[seg]; \n       \       If [MemberQ[bseg,rseg], {{k}}=Position[bseg,rseg,1,1]; \n              \bseg=Drop[bseg,{k}]; Continue[]]; \n              AppendTo[bseg,seg]];\n      \   ];\n      If [ne==3, {pb,pl}=ContourBandPlotFunctionOnTrig3[\n             \     xyc,fc,{fmin,fmax,finc,eps},lines]];\n      If [ne==4, \{pb,pl}=ContourBandPlotFunctionOnQuad4[\n                  \xyc,fc,{fmin,fmax,finc,eps},lines]];\n      If [ne==6, \{pb,pl}=ContourBandPlotFunctionOnTrig6[\n                  \xyc,fc,{fmin,fmax,finc,eps},lines]];\n      If [ne==8, \{pb,pl}=ContourBandPlotFunctionOnQuad8[\n                  \xyc,fc,{fmin,fmax,finc,eps},lines]];\n      If [ne==9, \{pb,pl}=ContourBandPlotFunctionOnQuad9[\n                  \xyc,fc,{fmin,fmax,finc,eps},lines]];\n      If \[ne==10,{pb,pl}=ContourBandPlotFunctionOnTrig10[\n                  \xyc,fc,{fmin,fmax,finc,eps},lines]];\n      If \[ne==16,{pb,pl}=ContourBandPlotFunctionOnQuad16[\n                  \xyc,fc,{fmin,fmax,finc,eps},lines]]; \n      If [colors, pband[[e]]=pb]; If \[lines, pline[[e]]=pl];\n      If [mesh,   pmesh[[e]]=Graphics[Line[xyb]]]; \n\      If [bacg,   pbacg[[e]]=Graphics[Polygon[xyb]]]; \n      If [nodes,  \pnode[[e]]=Table[Graphics[Point[xyb[[i]] ]],{i,ne}]];  ",  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n      ];\n If [!colors,pband={}]; If [!mesh, pmesh={}]; If [!nodes, \pnode={}]; \n If [!lines, pline={}]; If [!bacg, pbacg={}]; pleg={};",  StyleBox["\n ",    FontColor->RGBColor[1, 0, 0]],  "nbseg=Length[bseg];",  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n If [nbseg>0, pbound=Table[0,{nbseg}];  ",  StyleBox["(*Print[\"bseg=\",bseg];*)",    FontColor->RGBColor[1, 0, 0]],  "\n     For [k=1,k<=nbseg,k++, {i,j}=bseg[[k]];\n         \pbound[[k]]=Graphics[Line[{nodxyz[[i]],nodxyz[[j]]}]] ]];\n If \[Length[xyleg]==0||!colors, Show[prebacg,pbacg,\n     \preband,pband,preline,pline,premesh,pmesh,prenode,\n     \pnode,prebound,pbound,TextStyle->{FontFamily->\"Courier\",\n     \FontSlant->\"Plain\", FontSize->10},\n     \AspectRatio->aspect,PlotLabel->label,      \n     \DisplayFunction->DisplayChannel ]];\n If [Length[xyleg]>0&&colors,\n     \{preleg,pleg}=ContourPlotValueLegend[fmin,fmax,xyleg,6];\n     \Show[prebacg,pbacg,preband,pband,preline,pline,\n          \premesh,pmesh,prenode,pnode,prebound,pbound,preleg,pleg, \n          \TextStyle->{FontFamily->\"Courier\",\n                  FontSlant->\"Plain\", \FontSize->9},\n          AspectRatio->aspect,PlotLabel->label,\n          \DisplayFunction->DisplayChannel ]];\n \ClearAll[pband,pline,pmesh,pnode,pbacg,pbound,pleg]; \n ]; \n\n\ContourBandColor[f_,fmin_,fmax_]:= Module[{fs,h,s,b=1},\n   If [fmax==0 \||fmin>=fmax, (* White if wrong inputs *)\n       \Return[Graphics[RGBColor[1,1,1]] ]];\n   If [f>fmax || f<fmin, (* Black if \outside range *)\n       Return[Graphics[RGBColor[0,0,0]] ]]; \n   \fs=(fmax-f)/(fmax-fmin); h=0.70*fs; s=1-1/(1+100*(fs-1/2)^2);",  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n   Return[Graphics[Hue[h,s,b]]]];\n \n\TrigBandSegment[xs_,ys_,fs_,fv_,eps_]:=Module[{x1,x2,x3,\n  \y1,y2,y3,f1,f2,f3,x21,y21,x32,y32,x13,y13,f21,f32,f31,\n  \\[Zeta]211,\[Zeta]212,\[Zeta]311,\[Zeta]313,\[Zeta]322,\[Zeta]323,P1,P3,P21,\P32,P13}, \n  {x1,x2,x3}=xs; {y1,y2,y3}=ys; {f1,f2,f3}=fs; P1={x1,y1}; \P3={x3,y3};\n  If [fv<f1, Return[{{P1,P1},-1}]]; If [fv>f3, \Return[{{P3,P3},0}]];\n  f21=f2-f1; If [f21<eps,f1=f1-eps;f21=eps];\n  \f32=f3-f2; If [f32<eps,f3=f2+eps;f32=eps]; f31=f3-f1; \n  \\[Zeta]212=(fv-f1)/f21; \[Zeta]212=Max[Min[\[Zeta]212,1],0]; \[Zeta]211=1-\\[Zeta]212;\n  \[Zeta]313=(fv-f1)/f31; \[Zeta]313=Max[Min[\[Zeta]313,1],0]; \\[Zeta]311=1-\[Zeta]313;",  StyleBox["\n",    FontColor->RGBColor[1, 0, 0]],  "  P21={x2*\[Zeta]212+x1*\[Zeta]211,y2*\[Zeta]212+y1*\[Zeta]211};\n  \P13={x1*\[Zeta]311+x3*\[Zeta]313,y1*\[Zeta]311+y3*\[Zeta]313};\n  If \[fv<=f2,Return[{{P21,P13},1}]];\n  \[Zeta]323=(fv-f2)/f32; \\[Zeta]323=Max[Min[\[Zeta]323,1],0]; \[Zeta]322=1-\[Zeta]323; \n  P32={x3*\\[Zeta]323+x2*\[Zeta]322,y3*\[Zeta]323+y2*\[Zeta]322};\n  \Return[{{P32,P13},2}]];\n \n\ContourBandPlotFunctionOnTrig3[xyc_,fc_,{fmin_,fmax_,finc_,eps_},\n  \lines_]:=Module[{nv,iv,xc1,yc1,xc2,yc2,xc3,yc3,fc1,fc2,fc3,\n  \xs,ys,fs,x1,x2,x3,y1,y2,y3,f1,f2,f3,firsthit,Pc1,Pc2,Pc3,\n  \ftop,fbot,favg,Pb,Pt,tb,tt,P1,P2,P3,P4,Q1,Q2,Q3,Q4,ptab,\n  \flast,Plast,tlast,kb,kl,p,pb,pl}, \n  If [fmax<fmin||finc<=0, \Return[{{},{}}]];\n  nv=Floor[(fmax-fmin+eps)/finc]; nv=Min[nv,1000];",  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n  pb=Table[{},{nv}]; pl=Table[{},{nv+1}]; \n \{{xc1,yc1},{xc2,yc2},{xc3,yc3}}=N[xyc]; {fc1,fc2,fc3}=N[fc];\n  \{{x1,y1,f1},{x2,y2,f2},{x3,y3,f3}}=Sort[{{xc1,yc1,fc1},\n          \{xc2,yc2,fc2},{xc3,yc3,fc3}},#1[[3]]<=#2[[3]]&]; \n  xs={x1,x2,x3}; \ys={y1,y2,y3}; fs={f1,f2,f3}; \n  Pc1={x1,y1}; Pc2={x2,y2}; Pc3={x3,y3};\n  \ptab={{{},{Pc1,Pc2,Pc3},{Pc1,Q4,Q3},{Pc1,Pc2,Q3,Q4}},\n     \{{Null},{},{Null},{Null}},\n     \{{Null},{Pc3,Pc2,Q1,Q2},{Q1,Q2,Q4,Q3},{Pc2,Q1,Q2,Q4,Q3}},\n     \{{Null},{Pc3,Q1,Q2},{Null},{Q1,Q2,Q4,Q3}}};\n  flast=fmin-1000; \firsthit=True; kb=kl=0;\n  For [iv=1,iv<=nv,iv++, \n       \fbot=N[fmin+(iv-1)*finc]; ftop=N[fmin+iv*finc];\n       If [ftop<=f1 || \fbot>=f3, Continue[]]; favg=(fbot+ftop)/2;\n       If [fbot==flast, \{fbot,Pb,tb}={flast,Plast,tlast},\n          \{Pb,tb}=TrigBandSegment[xs,ys,fs,fbot,eps],\n          \{Pb,tb}=TrigBandSegment[xs,ys,fs,fbot,eps]]; \n       \{Pt,tt}=TrigBandSegment[xs,ys,fs,ftop,eps];\n       {P1,P2}=Pb; {P3,P4}=Pt; \{flast,Plast,tlast}={ftop,Pt,tt};\n       If [lines,\n          If \[firsthit&&(tb>0), ",  StyleBox[" \n              ",    FontColor->RGBColor[1, 0, 0]],  "pl[[++kl]]=Graphics[Line[Pb]]; firsthit=False];\n\t      If [tt>0, \pl[[++kl]]=Graphics[Line[Pt]]]\n\t      ];\n       \p=ptab[[tb+2,tt+2]]/.{Q1->P1,Q2->P2,Q3->P3,Q4->P4};\n       \pb[[++kb]]={ContourBandColor[favg,fmin,fmax],Graphics[Polygon[p]]};\n\t   ];  \",  StyleBox["\n  ",    FontColor->RGBColor[1, 0, 0]],  "If [kb>0,pb=Take[pb,kb],{},{}]; If [kl>0,pl=Take[pl,kl],{},{}];\n  \ClearAll[ptab]; Return[{pb,pl}];\n ];\n \n\ContourBandPlotFunctionOnQuad4[xyc_,fc_,{fmin_,fmax_,finc_,eps_},\n   \lines_]:=Module[{x1,x2,x3,x4,x5,y1,y2,y3,y4,y5,f1,f2,f3,f4,f5,\n   \e,xytab,ftab,xyt,ft, pbq,plq,pbt,plt },\n   pbq=plq=Table[{},{4}];\n   \{{x1,y1},{x2,y2},{x3,y3},{x4,y4}}=xyc; {f1,f2,f3,f4}=fc;\n   \x5=(x1+x2+x3+x4)/4; y5=(y1+y2+y3+y4)/4; f5=(f1+f2+f3+f4)/4;\n   \xytab={{{x1,y1},{x2,y2},{x5,y5}},{{x2,y2},{x3,y3},{x5,y5}},\n          \{{x3,y3},{x4,y4},{x5,y5}},{{x4,y4},{x1,y1},{x5,y5}}};\n   \ftab={{f1,f2,f5},{f2,f3,f5},{f3,f4,f5},{f4,f1,f5}};\n   For [e=1,e<=4,e++, \xyt=xytab[[e]]; ft=ftab[[e]];\n       \{pbq[[e]],plq[[e]]}=ContourBandPlotFunctionOnTrig3[\n            \xyt,ft,{fmin,fmax,finc,eps},lines];\n       ];       \n    Return[{pbq,plq}];\\n\t];\n\t\nContourBandPlotFunctionOnQuad9[xyc_,fc_,{fmin_,fmax_,finc_,eps_},\\n   lines_]:=Module[{x1,x2,x3,x4,x5,x6,x7,x8,x9,y1,y2,y3,y4,\n   \y5,y6,y7,y8,y9,f1,f2,f3,f4,f5,f6,f7,f8,f9,\n   e,xytab,ftab,xyt,ft, \pbq,plq,pbt,plt },\n   pbq=plq=Table[{},{4}];\n   \{{x1,y1},{x2,y2},{x3,y3},{x4,y4},\n    \{x5,y5},{x6,y6},{x7,y7},{x8,y8},{x9,y9}}=xyc; \n    \{f1,f2,f3,f4,f5,f6,f7,f8,f9}=fc;\n   \xytab={{{x1,y1},{x5,y5},{x9,y9},{x8,y8}},\n          \{{x2,y2},{x6,y6},{x9,y9},{x5,y5}},\n          \{{x3,y3},{x7,y7},{x9,y9},{x6,y6}},\n          \{{x4,y4},{x8,y8},{x9,y9},{x7,y7}}};\n   \ftab={{f1,f5,f9,f8},{f2,f6,f9,f5},{f3,f7,f9,f6},{f4,f8,f9,f7}};\n   For \[e=1,e<=4,e++, xye=xytab[[e]]; fe=ftab[[e]];\n       \{pbq[[e]],plq[[e]]}=ContourBandPlotFunctionOnQuad4[\n             \xye,fe,{fmin,fmax,finc,eps},lines];\n       ];       \n    Return[{pbq,plq}];\\n\t];\n\t\nContourBandPlotFunctionOnQuad8[xyc_,fc_,{fmin_,fmax_,finc_,eps_},\\n   lines_]:=Module[{x1,x2,x3,x4,x5,x6,x7,x8,x9,y1,y2,y3,y4,\n   \y5,y6,y7,y8,y9,f1,f2,f3,f4,f5,f6,f7,f8,f9,\n   e,xytab,ftab,xyt,ft, \pbq,plq,pbt,plt },\n   pbq=plq=Table[{},{4}];\n   \{{x1,y1},{x2,y2},{x3,y3},{x4,y4},\n    {x5,y5},{x6,y6},{x7,y7},{x8,y8}}=xyc; \\n    {f1,f2,f3,f4,f5,f6,f7,f8}=fc;\n   x9=(2*(x5+x6+x7+x8)-(x1+x2+x3+x4))/4;\\n   y9=(2*(y5+y6+y7+y8)-(y1+y2+y3+y4))/4;\n   \f9=(2*(f5+f6+f7+f8)-(f1+f2+f3+f4))/4;\n   \xytab={{{x1,y1},{x5,y5},{x9,y9},{x8,y8}},\n          \{{x2,y2},{x6,y6},{x9,y9},{x5,y5}},\n          \{{x3,y3},{x7,y7},{x9,y9},{x6,y6}},\n          \{{x4,y4},{x8,y8},{x9,y9},{x7,y7}}};\n   \ftab={{f1,f5,f9,f8},{f2,f6,f9,f5},{f3,f7,f9,f6},{f4,f8,f9,f7}};\n   For \[e=1,e<=4,e++, xye=xytab[[e]]; fe=ftab[[e]];\n       \{pbq[[e]],plq[[e]]}=ContourBandPlotFunctionOnQuad4[\n                   \xye,fe,{fmin,fmax,finc,eps},lines];\n       ];       \n    Return[{pbq,plq}];\\n\t];\n\t\n\ContourBandPlotFunctionOnQuad16[xyc_,fc_,{fmin_,fmax_,finc_,eps_},\n   \lines_]:=Module[{x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,\n   \x11,x12,x13,x14,x15,x16,y1,y2,y3,y4,y5,y6,y7,y8,y9,y10,\n   \y11,y12,y13,y14,y15,y16,f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,\n   \f11,f12,f13,f14,f15,f16,\n   e,xytab,ftab,xyt,ft, pbq,plq,pbt,plt },\n   \pbq=plq=Table[{},{9}];\n   {{x1,y1},{x2,y2},{x3,y3},{x4,y4},\n    \{x5,y5},{x6,y6},{x7,y7},{x8,y8},\n    {x9,y9},{x10,y10},{x11,y11},{x12,y12},\n\    {x13,y13},{x14,y14},{x15,y15},{x16,y16}}=xyc; \n   \{f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,\n    f13,f14,f15,f16}=fc;\n   \xytab={{{x1,y1},  {x5,y5},  {x13,y13},{x12,y12}},\n          {{x2,y2},  \{x7,y7},  {x14,y14},{x6,y6}},\n          {{x3,y3},  {x9,y9},  \{x15,y15},{x8,y8}},\n          {{x4,y4},  {x11,y11},{x16,y16},{x10,y10}},\n   \       {{x5,y5},  {x6,y6},  {x14,y14},{x13,y13}},\n          {{x7,y7},  \{x8,y8},  {x15,y15},{x14,y14}},\n          {{x9,y9},  \{x10,y10},{x16,y16},{x15,y15}},\n          \{{x11,y11},{x12,y12},{x13,y13},{x16,y16}},\n          \{{x13,y13},{x14,y14},{x15,y15},{x16,y16}}};\n   \ftab={{f1,f5,f13,f12},{f2,f7,f14,f6},{f3,f9,f15,f8},\n        \{f4,f11,f16,f10},{f5,f6,f14,f13},{f7,f8,f15,f14},\n        \{f9,f10,f16,f15},{f11,f12,f13,f16},{f13,f14,f15,f16}};\n   For [e=1,e<=9,e++, \xye=xytab[[e]]; fe=ftab[[e]];\n       \{pbq[[e]],plq[[e]]}=ContourBandPlotFunctionOnQuad4[\n                \xye,fe,{fmin,fmax,finc,eps},lines];\n       ];       \n    Return[{pbq,plq}];\\n\t];\n\t\nContourBandPlotFunctionOnTrig6[xyc_,fc_,{fmin_,fmax_,finc_,eps_},\\n   lines_]:=Module[{x1,x2,x3,x4,x5,x6,y1,y2,y3,y4,y5,y6,\n   \f1,f2,f3,f4,f5,f6,e,xytab,ftab,xyt,ft,pbt,plt,pbe,ple},\n   \pbt=plt=Table[{},{4}];\n   \{{x1,y1},{x2,y2},{x3,y3},{x4,y4},{x5,y5},{x6,y6}}=xyc; \n   \{f1,f2,f3,f4,f5,f6}=fc;\n   \xytab={{{x1,y1},{x4,y4},{x6,y6}},{{x2,y2},{x5,y5},{x4,y4}},\n          \{{x3,y3},{x6,y6},{x5,y5}},{{x4,y4},{x5,y5},{x6,y6}}};\n   \ftab={{f1,f4,f6},{f2,f5,f4},{f3,f6,f5},{f4,f5,f6}};\n   For [e=1,e<=4,e++, \xyt=xytab[[e]]; ft=ftab[[e]];\n       \{pbt[[e]],plt[[e]]}=ContourBandPlotFunctionOnTrig3[\n             \xyt,ft,{fmin,fmax,finc,eps},lines];\n       ];       \n    Return[{pbt,plt}];\\n\t];\n\t\n\ContourBandPlotFunctionOnTrig10[xyc_,fc_,{fmin_,fmax_,finc_,eps_},\n   \lines_]:=Module[{x1,x2,x3,x4,x5,x6,x7,x8,x9,x0,y1,y2,y3,\n   \y4,y5,y6,y7,y8,y9,y0,f1,f2,f3,f4,f5,f6,f7,f8,f9,f0,\n   \e,xytab,ftab,xyt,ft,pbt,plt},\n   pbt=plt=Table[{},{9}];",  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n   {{x1,y1},{x2,y2},{x3,y3},{x4,y4},{x5,y5},{x6,y6},\n    \{x7,y7},{x8,y8},{x9,y9},{x0,y0}}=xyc; \n   \{f1,f2,f3,f4,f5,f6,f7,f8,f9,f0}=fc;\n   \xytab={{{x1,y1},{x4,y4},{x9,y9}},{{x2,y2},{x6,y6},{x5,y5}},\n          \{{x3,y3},{x8,y8},{x7,y7}},{{x9,y9},{x4,y4},{x0,y0}},\n          \{{x4,y4},{x5,y5},{x0,y0}},{{x5,y5},{x6,y6},{x0,y0}},\n          \{{x6,y6},{x7,y7},{x0,y0}},{{x7,y7},{x8,y8},{x0,y0}},\n          \{{x8,y8},{x9,y9},{x0,y0}}};\n   \ftab={{f1,f4,f9},{f2,f6,f5},{f3,f8,f7},{f9,f4,f0},\n         \{f4,f5,f0},{f5,f6,f0},{f6,f7,f0},{f7,f8,f0},\n         {f8,f9,f0}};\n   For \[e=1,e<=9,e++, xyt=xytab[[e]]; ft=ftab[[e]];\n       \{pbt[[e]],plt[[e]]}=ContourBandPlotFunctionOnTrig3[\n            \xyt,ft,{fmin,fmax,finc,eps},lines];\n       ];     \n    Return[{pbt,plt}];\n\\t];\n\t\nContourPlotValueLegend[fmin_,fmax_,xyleg_,mv_]:=Module[\n  \{f,fs,finc,fa=Abs[fmin],fb=Abs[fmax],xylinL,xylinR,xytext,\n   \black=Graphics[RGBColor[0,0,0]],baselineskip=10,\n   \white=Graphics[RGBColor[1,1,1]],preleg,plab,iv,\n   \thick=Graphics[AbsoluteThickness[10]],xf1,xf2,xf3,xf4,\n   thin= \Graphics[AbsoluteThickness[1]],color,padOK},\n   xf1=Offset[{-30,  \10},xyleg]; xf2=Offset[{85,10},xyleg];\n   xf3=Offset[{ \85,-10-baselineskip*(mv+1)},xyleg];\n   \xf4=Offset[{-30,-10-baselineskip*(mv+1)},xyleg];\n   preleg={thin,white,\n    \   Graphics[Polygon[{xf1,xf2,xf3,xf4}]], black,\n       \Graphics[Line[{xf1,xf2,xf3,xf4,xf1}]],thick,\n       \Graphics[Text[\"LEGEND\",Offset[{5,0},xyleg],{-1,0}]]};\n   \finc=(fmax-fmin)/mv; plab=Table[{},{mv+1}];",  StyleBox[" ",    FontColor->RGBColor[1, 0, 0]],  "\n   padOK=(Max[fa,fb]<=1000)&&(Min[fa,fb]>=1/100);\n   For \[iv=1,iv<=mv+1,iv++, f=N[fmin+(iv-1)*finc]; \n        \xylinL=Offset[{-20,-baselineskip*iv},xyleg];\n        xylinR=Offset[{  \5,-baselineskip*iv},xyleg]; \n        xytext=Offset[{ \80,-baselineskip*iv},xyleg];\n        If [padOK, \fs=PaddedForm[f,4,NumberSigns->{\"-\",\"+\"}],\n               \fs=ScientificForm[f,4,NumberSigns->{\"-\",\"+\"}]];\n        \color=ContourBandColor[f,fmin,fmax]; \n        \plab[[iv]]={color,Graphics[Line[{xylinL,xylinR}]],\n                    \black,Graphics[Text[fs,xytext,{1,0}]]}]; \n   Return[{preleg,plab}]];\n\n(*",  StyleBox["nodxyz=N[{{0,6},{0,3},{0,0},{5/2,6},{5/2,3},\n     \{5/2,0},{5,6},{5,3},{5,0}}];        \nelenod=  {{1,3,9,7,2,6,8,4,5}};\n\sxx=Table[8*nodxyz[[n,1]]/5-4,{n,1,9}]; sxxmax=4; sxxmin=-4;\n sxxinc=.5; \aspect=6/5; Print[\"sxx=\",sxx];\n\ContourBandPlotNodeFuncOver2DMesh[nodxyz,elenod,sxx,{sxxmin,sxxmax,sxxinc},\n \ {True,True,True,True,True,True},{2,2.5},aspect,\"Sigma-xx (white: zero)\"];\n\syy=Table[4*nodxyz[[n,2]]/6,{n,1,9}]; syymax=4; syymin=-4;\nsyyinc=.5; \aspect=6/5; Print[\"syy=\",syy];\n\ContourBandPlotNodeFuncOver2DMesh[nodxyz,elenod,syy,{syymin,syymax,syyinc},\n \ {True,True,True,True,True,True},{2,2.5},aspect,\"Sigma-yy (white: zero)\"];  \*)",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["Cell 10. Print utility modules.", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "PrintPoissonNodeCoordinates[nodxyz_,title_,digits_]:= Module[\n  \{numnod=Length[nodxyz],n,x,y,z,d=6,f=6,tab}, \n   tab=Table[0,{numnod}]; If \[Length[digits]==2,{d,f}=digits];\n   For \[n=1,n<=numnod,n++,{x,y}=nodxyz[[n]]; \n       \tab[[n]]={ToString[n],PaddedForm[x,{d,f}],PaddedForm[y,{d,f}]}];\n   If \[StringLength[title]>0, Print[title]];\n   Print[TableForm[tab, \TableAlignments->{Right},   \n      \TableDirections->{Column,Row},TableSpacing->{0,2},\n      TableHeadings \->{None,{\"node\", \"x-coor\", \"y-coor\"}}]];\n   ClearAll[tab];\n   ];\n   \\nPrintPoissonElementNodesMatFab[elenod_,elemat_,elefab_,title_,digits_]:= \n \ Module[{e,numele=Length[elenod],mat,fab,d=6,f=3,tab}, \n   \tab=Table[0,{numele}]; If [Length[digits]==2,{d,f}=digits];\n   For \[e=1,e<=numele,e++, mat=elemat[[e]]; fab=elefab[[e]];\n        \tab[[e]]={ToString[e],ToString[elenod[[e]]],\n            \PaddedForm[mat,{d,f}],PaddedForm[fab,{d,f}]}];\n   If [StringLength[title]>0, \Print[title]];\n   Print[TableForm[tab, TableAlignments->Right,\n         \TableDirections->{Column,Row},TableSpacing->{0,1},\n         \TableHeadings->{None,{\"elem\", \"nodelist\", \n         \"conductivity\", \\"thickness\"}}]];\n   ClearAll[tab];\n   ];\n   \n\PrintPoissonElementForces[elenod_,elefor_,title_,digits_]:= \n  \Module[{e,numele=Length[elefor],sq,s,q12,q23,q34,q45,d=6,f=3,tab}, \n   \tab=Table[0,{numele}]; If [Length[digits]==2,{d,f}=digits];\n   For \[e=1,e<=numele,e++, s=q12=q23=q34=q41=0; sq=elefor[[e]];\n        If \[Length[sq]==1, {s}=sq];\n        If [Length[sq]==2, \{s,{q12,q23,q34,q41}}=sq];\n        \tab[[e]]={ToString[e],ToString[elenod[[e]]],\n            \PaddedForm[s,{d,f}],\n            \PaddedForm[q12,{d,f}],PaddedForm[q23,{d,f}],\n            \PaddedForm[q34,{d,f}],PaddedForm[q41,{d,f}]}];\n   If [StringLength[title]>0, \Print[title]];\n   Print[TableForm[tab, TableAlignments->Right,\n         \TableDirections->{Column,Row},TableSpacing->{0,1},\n         \TableHeadings->{None,{\"elem\", \"nodelist\", \"source s\",\n         \"flux \q12\", \"flux q23\", \"flux q34\", \"flux q41\"}}]];\n   ClearAll[tab];\n   \];\n   \nPrintPoissonFreedomActivity[nodtag_,nodval_,title_,digits_]:= \Module[\n  {numnod=Length[nodtag],n,t,v,d=6,f=2,tab}, \n   \tab=Table[0,{numnod}]; If [Length[digits]==2,{d,f}=digits];\n   For \[n=1,n<=numnod,n++, t=nodtag[[n]]; v=nodval[[n]];\n        \tab[[n]]={ToString[n],\n          PaddedForm[t,d],PaddedForm[v,{d,f}] } ];\n  \ If [StringLength[title]>0, Print[title]];\n   \Print[TableForm[tab,TableAlignments->{Right},\n         \TableDirections->{Column,Row},TableSpacing->{0,1},\n         \TableHeadings->{None,{\"node\", \"DOF-tag\", \"DOF-value\"}} ]];\n   \ClearAll[tab];\n   ];\n\n\PrintPoissonNodeTempForces[nodtem_,nodfor_,title_,digits_]:= Module[\n  \{numnod=Length[nodtem],n,Tn,Fn,d=8,f=6,tab}, \n  tab=Table[0,{numnod}]; If \[Length[digits]==2,{d,f}=digits]; \n   For [n=1,n<=numnod,n++, \{Tn,Fn}={nodtem[[n]],nodfor[[n]]};\n       \tab[[n]]={ToString[n],PaddedForm[Tn,{d,f}],PaddedForm[Fn,{d,f}]}];\n   If \[StringLength[title]>0, Print[title]];\n   \Print[TableForm[tab,TableAlignments->{Right},\n         \TableDirections->{Column,Row},TableSpacing->{0,1},\n         \TableHeadings->{None,{\"node\", \"temperature\",\"thermal-force\"}}]];\n   \ClearAll[tab];\n   ];\n   \n",  StyleBox["(*nodxyz= N[{{0,10},{0,0},{10,10},{10,0},{15,5},{20,0}}];\n\elenod={{1,2,4,3},{3,4,6,5}};  \nelemat={3.5,1.6}; elefab={1,1};  \nodtem={4,-6}; nodfor={12,-54};\nelefor={{-6,{3,-4,0,0}},{4}};\n\nodtag={1,1,0,0,1,1}; nodval={100,50,0,0,0,60,30}; \n\PrintPoissonNodeCoordinates[nodxyz,\"Node Coordinate Data\",{8,4}];\n\PrintPoissonElementNodesMatFab[elenod,elemat,elefab,\"Element Data\",{9,6}]; \\nPrintPoissonElementForces[elenod,elefor,\"Element Forces\",{6,3}];\n\PrintPoissonFreedomActivity[nodtag,nodval,\"DOF Activity Data\",{6,4}];\n\PrintPoissonNodeTempForces[nodtem,nodfor,\"Computed Solution\",{6,3}];*)",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 11. Linear solution module driver for Poisson problem \analysis.  It returns the computedsolution u of K u = f and the recovered node forces f = Ku.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell[TextData[{  "LinearSolutionOfPoissonModel[nodcoor_,eletyp_,elenod_,elemat_,\n   \elefab_,elefor_,doftag_,dofval_,eleopt_]:=Module[\n   \{numnod=Length[nodcoor],K,Kmod,u,f,fmod,pdof=pval={} },\n   \K=MasterStiffnessPoisson[nodcoor,eletyp,elenod,\n          \elemat,elefab,eleopt];\n   f=MasterNodeForcesPoisson[nodcoor,eletyp,elenod,\n \         elemat,elefab,elefor,eleopt];\n   (*Print[\"f=\",f];*)\n   For \[n=1,n<=numnod,n++,If [doftag[[n]]>0,AppendTo[pdof,n];\n       \AppendTo[pval,dofval[[n]]]] ];\n   (*Print[\"pdof=\",pdof]; \Print[\"pval=\",pval];*) \n   fmod=ModifiedNodeForces[pdof,pval,K,f];         \  \n   Kmod=ModifiedMasterStiffness[pdof,K]; \n   u=LinearSolve[Kmod,fmod]; \u=Chop[u];\n   f=Simplify[K.u]; f=Chop[f];\n   Return[{u,f}]\n ];\n\n",  StyleBox[" \nClearAll[];\neletyp=Table[\"Quad4\",{2}]; (* eletyp is dummy \placeholder  *)\nnodcoor={{0,4},{0,0},{3,4},{3,0},{4,4},{4,0}};\n\elenod={{1,2,4,3},{3,4,6,5}}; elemat={12,12}; elefab={1,1};\n\elefor={{1},{2}}; eleopt={True};\ndoftag={1,1,0,0,1,1};  \dofval={100,60,0,0,30,20};     \n\{u,f}=LinearSolutionOfPoissonModel[nodcoor,eletyp,elenod,\n    \elemat,elefab,elefor,doftag,dofval,eleopt];\nPrint[\"Computed \temperatures=\",u];\nPrint[\"recovered forces=\",f];",    FontColor->RGBColor[0, 0, 1]]}], "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  InitializationCell->True,  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 12A. Analysis of rectangular region with rectangular hole, \with prescribed temperature T=100 over hole boundary. Constant fluxes qx,qy over boundaries normal to x,y, \resp.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell["\<\(*  Define FE model *)NodeCoordinates={{0,3},{0,2},{0,1},{0,0},{2,3},{2,2},{2,1},    {2,0},{4,3},{4,2},{4,1},{4,0},{6,3},{6,2},{6,1},{6,0}};ElemNodes={{1,2,6,5},{2,3,7,6},{3,4,8,7},{5,6,10,9},    {7,8,12,11},{9,10,14,13},{10,11,15,14},{11,12,16,15}};numele=Length[ElemNodes]; numnod=Length[NodeCoordinates]; ElemTypes=Table[\"Quad4\",{numele}];ElemMaterial=Table[12,{numele}];  ElemFabrication=Table[1,{numele}];ElemForces=Table[{0,{0,0,0,0}},{numele}];  qx=-500; qy=1500;ElemForces[[1]]={0,{qx,0,0,qy}};ElemForces[[2]]={0,{qx,0,0,0}};ElemForces[[3]]={0,{qx,qy,0,0}};ElemForces[[4]]={0,{0,0,0,qy}};ElemForces[[5]]={0,{0,qy,0,0}}; ElemForces[[6]]={0,{0,0,qx,qy}};ElemForces[[7]]={0,{0,0,qx,0}}; ElemForces[[8]]={0,{0,qy,qx,0}};ProcessOptions={True};PrintPoissonNodeCoordinates[NodeCoordinates,\"Node Coordinate Data\",{8,4}];PrintPoissonElementNodesMatFab[ElemTypes,ElemNodes,ElemMaterial,\ElemFabrication,       \"Element Data\",{9,4}]; PrintPoissonElementForces[ElemNodes,ElemForces,\"Element Forces\",{6,3}];FreedomValues=FreedomTags=Table[0,{numnod}]; (* initialize & clear *)FreedomValues[[6]]=FreedomValues[[7]]=FreedomValues[[10]]=FreedomValues[[11]]=100; (* T=100 at 4 hole nodes *)FreedomTags[[6]]=FreedomTags[[7]]=FreedomTags[[10]]=FreedomTags[[11]]=1;     (* prescribed T at hole*)PrintPoissonFreedomActivity[FreedomTags,FreedomValues,\"DOF Activity \Data\",{6,3}];elepar={9,1.5,1,12,{0.15,1,1}};nodpar={3.5,1.5,-8,5,11,{0.7,0.2,0.9}}; typspec={}; Plot2DMesh[NodeCoordinates,ElemTypes,ElemNodes,{},typspec,  nodpar,elepar,{True,True,True,True,True},1/2,\"Plot of FEM Mesh\"];(*  Solve problem and print results *){u,f}=LinearSolutionOfPoissonModel[NodeCoordinates,      ElemTypes,ElemNodes,ElemMaterial,ElemFabrication,      ElemForces,FreedomTags,FreedomValues,ProcessOptions];PrintPoissonNodeTempForces[u,f,\"Computed Solution\",{6,4}];(*  Contourplot temperature distribution *)umax=Max[Abs[u]]; Nsub=8;ContourPlotNodeFuncOver2DMesh[NodeCoordinates,ElemNodes,  u,umax,Nsub,1/2,\"Computed Temp Dist: Polygon Plotter\"];ContourBandPlotNodeFuncOver2DMesh[NodeCoordinates, ElemNodes,u,{-umax,umax,umax/100},{True,False,False,False, False,False},{},1/2,\"Computed Temp Dist: Band Plotter\"];\\>", "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 12B. Two element \"dam\" problem, explained in Addendum B of \take homefinal exam.    T=100 over side 1-2. Flux q=60 Sqrt[2]  over 3-5-6, else q=0.  \The exact solution is a linear distribution of temperature depending only on \x,varying from T=+100 at x=0 to T=-100 at x=20.  *Any* mesh should reproduce \thisexact solution.  Note that element 2 is a quad although it is shaped like a \triangle.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell["\<\(*  Define FE model *)NodeCoordinates= N[{{0,10},{0,0},{10,10},{10,0},{15,5},{20,0}}];ElemNodes={{1,2,4,3},{3,4,6,5}}; PrintPoissonNodeCoordinates[NodeCoordinates,      \"Node Coordinate Data\",{8,4}];numele=Length[ElemNodes]; numnod=Length[NodeCoordinates];ElemTypes=Table[\"Quad4\",{numele}];  ElemMaterial=Table[12,{numele}]; ElemFabrication=Table[1,{numele}];ElemForces=Table[{0,{0,0,0,0}},{numele}];ElemForces[[2]]={0,{0,0,N[60*Sqrt[2]],N[60*Sqrt[2]]}};PrintPoissonElementNodesMatFab[ElemNodes,ElemMaterial,       ElemFabrication,\"Element Data\",{9,4}];PrintPoissonElementForces[ElemNodes,ElemForces,      \"Element Forces\",{6,3}]; FreedomValues=FreedomTags=Table[0,{numnod}];FreedomValues[[1]]=FreedomValues[[2]]=100; (* T @ 1,2*)FreedomTags[[1]]=FreedomTags[[2]]=1; (* prescribed T *)PrintPoissonFreedomActivity[FreedomTags,FreedomValues,       \"DOF Activity Data\",{6,3}];    elepar={9,1.5,1,12,{0.15,1,1}};nodpar={3.5,1.5,-8,5,12,{0.7,0.2,0.9}}; typspec={}; Plot2DMesh[NodeCoordinates,ElemTypes,ElemNodes,{},typspec,  nodpar,elepar,{False,True,True,True,True},Automatic,  \"Plot of FEM Mesh\"];ProcessOptions={True};  (*  Solve problem and print results *){u,f}=LinearSolutionOfPoissonModel[NodeCoordinates,      ElemTypes,ElemNodes,ElemMaterial,ElemFabrication,      ElemForces,FreedomTags,FreedomValues,ProcessOptions];PrintPoissonNodeTempForces[u,f,\"Computed Solution\",{6,4}];(* Contour plot temperature distribution: 2 plotters tested *)umax=Max[Abs[u]]; Nsub=8;ContourPlotNodeFuncOver2DMesh[NodeCoordinates,ElemNodes,  u,umax,Nsub,1/2,\"Computed Temp Dist: Polygon Plotter\"];ContourBandPlotNodeFuncOver2DMesh[NodeCoordinates, ElemNodes,u,{-umax,umax,umax/10},{True,False,False,False, False,False},{},1/2,\"Computed Temp Dist: Band Plotter\"];\\>", "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 12C. Same problem as in cell above but with more elements.  \Again the exact solution should be reproduced.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell["\<\(*  Define FE model *)NodeCoordinates= {{0,10},{0,5},{0,0},{5,10},{5,5},{5,0},{10,10},  {10,5},{10,0},{12.5,7.5},{15,5},{15,0},{17.5,2.5},{20,0}};ElemNodes={{1,2,5,4},{2,3,6,5},{4,5,8,7},{5,6,9,8},               {7,8,11,10}, {8,9,12,11},{11,12,14,13}};  numele=Length[ElemNodes]; numnod=Length[NodeCoordinates];ElemTypes=Table[\"Quad4\",{numele}];ElemMaterial=Table[12,{numele}];  ElemFabrication=Table[1,{numele}];ElemForces=Table[{0,{0,0,0,0}},{numele}];ElemForces[[5]]=ElemForces[[7]]={0,{0,0,N[60*Sqrt[2]],N[60*Sqrt[2]]}};ProcessOptions={True};PrintPoissonNodeCoordinates[NodeCoordinates,\"Node Coordinate Data\",{8,4}];PrintPoissonElementNodesMatFab[ElemTypes,ElemNodes,ElemMaterial,\ElemFabrication,       \"Element Data\",{9,4}]; PrintPoissonElementForces[ElemNodes,ElemForces,\"Element Forces\",{6,3}]; FreedomValues=FreedomTags=Table[0,{numnod}];FreedomValues[[1]]=FreedomValues[[2]]=FreedomValues[[3]]=100; FreedomTags[[1]]=FreedomTags[[2]]=FreedomTags[[3]]=1;  PrintPoissonFreedomActivity[FreedomTags,FreedomValues,\"DOF Activity \Data\",{6,3}];     elepar={9,1.5,1,12,{0.15,1,1}};nodpar={3.5,1.5,-8,5,12,{0.7,0.2,0.9}}; typspec={}; Plot2DMesh[NodeCoordinates,ElemTypes,ElemNodes,{},typspec,  nodpar,elepar,{False,True,True,True,True},Automatic,\"Plot of FEM Mesh\"];  (*  Solve problem and print results *){u,f}=LinearSolutionOfPoissonModel[NodeCoordinates,      ElemTypes,ElemNodes,ElemMaterial,ElemFabrication,      ElemForces,FreedomTags,FreedomValues,ProcessOptions];PrintPoissonNodeTempForces[u,f,\"Computed Solution\",{6,4}];(*  Contourplot temperature distribution *)umax=Max[Abs[u]]; Nsub=8;ContourPlotNodeFuncOver2DMesh[NodeCoordinates,ElemNodes,  u,umax,Nsub,1/2,\"Computed Temp Dist: Polygon Plotter\"];ContourBandPlotNodeFuncOver2DMesh[NodeCoordinates, ElemNodes,u,{-umax,umax,umax/20},{True,False,False,False, False,False},{},1/2,\"Computed Temp Dist: Band Plotter\"];\\>", "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 12D. Same problem and mesh as Cell 12C, but with specified \heat sink (negative source) over element 6.  Flux q=0 over all boundaries except 1-2-3.  The minimum \temperature occurs at node 9.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell["\<\(*  Define FE model *)NodeCoordinates= {{0,10},{0,5},{0,0},{5,10},{5,5},{5,0},{10,10},  {10,5},{10,0},{12.5,7.5},{15,5},{15,0},{17.5,2.5},{20,0}};ElemNodes={{1,2,5,4},{2,3,6,5},{4,5,8,7},{5,6,9,8},           {7,8,11,10}, {8,9,12,11},{11,12,14,13}};numnod=Length[NodeCoordinates]; numele=Length[ElemNodes];ElemTypes=Table[\"Quad4\",{numele}];ElemMaterial=Table[12,{numele}]; ElemFabrication=Table[1,{numele}];ElemForces=Table[{0,{0,0,0,0}},{numele}];ElemForces[[4]]={-100,{0,0,0,0}};PrintPoissonNodeCoordinates[NodeCoordinates,\"Node Coordinate Data\",{8,4}];PrintPoissonElementNodesMatFab[ElemTypes,ElemNodes,ElemMaterial,\ElemFabrication,       \"Element Data\",{9,4}]; PrintPoissonElementForces[ElemNodes,ElemForces,\"Element Forces\",{6,3}];FreedomValues=FreedomTags=Table[0,{numnod}];FreedomValues[[1]]=FreedomValues[[2]]=FreedomValues[[3]]=100;FreedomTags[[1]]=FreedomTags[[2]]=FreedomTags[[3]]=1; ProcessOptions={True};PrintPoissonFreedomActivity[FreedomTags,FreedomValues,\"DOF Activity \Data\",{6,3}];      elepar={9,1.5,1,12,{0.15,1,1}};nodpar={3.5,1.5,-8,5,12,{0.7,0.2,0.9}}; typspec={}; Plot2DMesh[NodeCoordinates,ElemTypes,ElemNodes,{},typspec,  nodpar,elepar,{False,True,True,True,True},Automatic,\"Plot of FEM Mesh\"];  (*  Solve problem and print results *){u,f}=LinearSolutionOfPoissonModel[NodeCoordinates,      ElemTypes,ElemNodes,ElemMaterial,ElemFabrication,      ElemForces,FreedomTags,FreedomValues,ProcessOptions];PrintPoissonNodeTempForces[u,f,\"Computed Solution\",{6,4}];(*  ContourPlotPlot temperature distribution *)umax=0; umax=Max[Abs[u]]; Nsub=8;ContourPlotNodeFuncOver2DMesh[NodeCoordinates,ElemNodes,  u,umax,Nsub,1/2,\"Computed Temp Dist: Polygon Plotter\"];ContourBandPlotNodeFuncOver2DMesh[NodeCoordinates, ElemNodes,u,{-umax,umax,umax/50},{True,False,False,False, False,False},{},1/2,\"Computed Temp Dist: Band Plotter\"];\\>", "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]],Cell["\<\Cell 13. Thermal analysis of electronic package by a very coarse \mesh of 15 nodes and 8 elements. See mesh plot below.\\>", "Text",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->RGBColor[1, 1, 0]],Cell["\<\(*  Define FE model *)ClearAll[a,b,c,d,f,g,e,kSi,kCu,kCer,th,Tbot,sSi,qSi,qCer];a=25; b=10; c=5; d=3.75; e=0.1;  Tbot=-20; th=1;kSi=150; kCu=400; kCer=40; sSi=16000; qSi=25; qCer=10;NodeCoordinates= {{0,b+e},{0,b},{0,0.8*b},{0,0},   {d,b+e},{d,b},{d,0.8*b},{d,0},   {1.25*d,b+e},{1.25*d,b},{1.25*d,0.8*b},{1.25*d,0},   {a,b},{a,0.8*b},{a,0}};ElemNodes={{1,2,6,5},{2,3,7,6},{3,4,8,7},           {5,6,10,9},{6,7,11,10},{7,8,12,11},           {10,11,14,13},{11,12,15,14} }; numnod=Length[NodeCoordinates]; numele=Length[ElemNodes]; ElemTypes=Table[\"Quad4\",{numele}];ElemMaterial=Table[0,{numele}]; ElemMaterial[[1]]=ElemMaterial[[4]]=kSi;  (* silicon *)ElemMaterial[[2]]=ElemMaterial[[3]]=kCu;  (* copper  *)ElemMaterial[[5]]=ElemMaterial[[6]]=kCer; (* ceramic *)ElemMaterial[[7]]=ElemMaterial[[8]]=kCer; (* ceramic *)ElemFabrication=Table[th,{numele}];    (* unit z thickness *)ElemForces=Table[{0,{0,0,0,0}},{numele}];ElemForces[[1]]={sSi,  {0,0,0,qSi}};   (* silicon source & flux *)ElemForces[[4]]={sSi,  {0,0,qSi,qSi}}; (* silicon source 7 fluxes *)ElemForces[[7]]={0,{0,0,0,qCer}};      (* ceramic fluxes *) PrintPoissonNodeCoordinates[NodeCoordinates,\"Node Coordinate Data\",{8,4}];PrintPoissonElementNodesMatFab[ElemTypes,ElemNodes,ElemMaterial,\ElemFabrication,       \"Element Data\",{8,3}]; PrintPoissonElementForces[ElemNodes,ElemForces,\"Element Forces\",{6,3}];FreedomValues=FreedomTags=Table[0,{numnod}];FreedomValues[[4]]=FreedomValues[[8]]=FreedomValues[[12]]=FreedomValues[[15]]=Tbot;  (* Chilling plate temperature *)FreedomTags[[4]]=FreedomTags[[8]]=FreedomTags[[12]]= FreedomTags[[15]]=1;     (* Specified T at chilling plate *)PrintPoissonFreedomActivity[FreedomTags,FreedomValues,\"DOF Activity \Data\",{6,3}];ProcessOptions={True};  aspect=4/10;    elepar={9,1.5,1,12,{0.15,1,1}};nodpar={3.5,1.5,-8,5,12,{0.7,0.2,0.9}}; typspec={}; Plot2DMesh[NodeCoordinates,ElemTypes,ElemNodes,{},typspec,  nodpar,elepar,{False,True,True,True,True},Automatic,  \"Electronic Package: Coarse Mesh\"]; (* zoom plot to see chip better *)(*  Solve problem and print results *){u,f}=LinearSolutionOfPoissonModel[NodeCoordinates,      ElemTypes,ElemNodes,ElemMaterial,ElemFabrication,      ElemForces,FreedomTags,FreedomValues,ProcessOptions];PrintPoissonNodeTempForces[u,f,\"Computed Solution\",{6,4}];(*  Plot temperature distribution *)umax=0; umax=Max[Abs[u]]; Nsub=16;ContourPlotNodeFuncOver2DMesh[NodeCoordinates,ElemNodes,  u,umax,Nsub,1/2,\"Computed Temp Dist: Polygon Plotter\"];ContourBandPlotNodeFuncOver2DMesh[NodeCoordinates, ElemNodes,u,{-umax,umax,umax/20},{True,False,False,False, False,False},{},1/2,\"Computed Temp Dist: Band Plotter\"];ContourBandPlotNodeFuncOver2DMesh[NodeCoordinates, ElemNodes,u,{-umax,umax,umax/20},{True,False,False,False, False,False},{5,7},1/2,\"Computed Temp Dist: Band Plotter\"]; \\>", "Input",  CellFrame->True,  CellMargins->{{17, 76}, {Inherited, Inherited}},  CellLabelMargins->{{8, Inherited}, {Inherited, Inherited}},  ImageRegion->{{-0, 1}, {0, 1}},  Background->GrayLevel[0.899992]]},FrontEndVersion->"4.2 for Macintosh",ScreenRectangle->{{0, 1920}, {0, 1180}},AutoGeneratedPackage->None,WindowToolbars->{},CellGrouping->Manual,WindowSize->{1729, 1105},WindowMargins->{{6, Automatic}, {Automatic, 9}},PrivateNotebookOptions->{"ColorPalette"->{RGBColor, -1}},ShowCellLabel->True,ShowCellTags->False,RenderingOptions->{"ObjectDithering"->True,"RasterDithering"->False},Magnification->1.5,MacintoshSystemPageSetup->"\<\00<0001804P000000]P2:?oQon82n@960dL5:0?l0080001804P000000]P2:0010000I00000400`<300000BL?00400@00000000000000060801T1T0000000000000000000000000000000000000000000\>"](*******************************************************************Cached data follows.  If you edit this Notebook file directly, notusing Mathematica, you must remove the line containing CacheID atthe top of  the file.  The cache data will then be recreated whenyou save this file from within Mathematica.*******************************************************************)(*CellTagsOutlineCellTagsIndex->{}*)(*CellTagsIndexCellTagsIndex->{}*)(*NotebookFileOutlineNotebook[{Cell[1754, 51, 2942, 50, 799, "Text"],Cell[4699, 103, 337, 10, 71, "Text"],Cell[5039, 115, 437, 11, 102, "Input",  InitializationCell->True],Cell[5479, 128, 340, 7, 62, "Input",  InitializationCell->True],Cell[5822, 137, 393, 10, 93, "Text",  InitializationCell->True],Cell[6218, 149, 1189, 22, 402, "Input",  InitializationCell->True],Cell[7410, 173, 370, 9, 93, "Text"],Cell[7783, 184, 1460, 36, 622, "Input",  InitializationCell->True],Cell[9246, 222, 529, 12, 141, "Text"],Cell[9778, 236, 1690, 31, 562, "Input",  InitializationCell->True],Cell[11471, 269, 605, 15, 165, "Text"],Cell[12079, 286, 1487, 27, 582, "Input",  InitializationCell->True],Cell[13569, 315, 1052, 22, 237, "Text"],Cell[14624, 339, 1282, 23, 482, "Input",  InitializationCell->True],Cell[15909, 364, 523, 12, 117, "Text"],Cell[16435, 378, 1469, 27, 602, "Input",  InitializationCell->True],Cell[17907, 407, 492, 12, 117, "Text"],Cell[18402, 421, 1725, 31, 722, "Input",  InitializationCell->True],Cell[20130, 454, 548, 13, 141, "Text"],Cell[20681, 469, 1428, 25, 642, "Input",  InitializationCell->True],Cell[22112, 496, 364, 9, 93, "Text"],Cell[22479, 507, 18693, 323, 6934, "Input",  InitializationCell->True],Cell[41175, 832, 837, 20, 213, "Text"],Cell[42015, 854, 4143, 105, 2002, "Input",  InitializationCell->True],Cell[46161, 961, 780, 17, 213, "Text"],Cell[46944, 980, 16600, 282, 6122, "Input",  InitializationCell->True],Cell[63547, 1264, 274, 6, 69, "Text",  InitializationCell->True],Cell[63824, 1272, 4313, 70, 1622, "Input",  InitializationCell->True],Cell[68140, 1344, 378, 9, 93, "Text"],Cell[68521, 1355, 1539, 27, 622, "Input",  InitializationCell->True],Cell[70063, 1384, 404, 10, 93, "Text"],Cell[70470, 1396, 2471, 53, 942, "Input"],Cell[72944, 1451, 633, 16, 165, "Text"],Cell[73580, 1469, 2029, 48, 882, "Input"],Cell[75612, 1519, 337, 9, 93, "Text"],Cell[75952, 1530, 2160, 48, 842, "Input"],Cell[78115, 1580, 422, 10, 93, "Text"],Cell[78540, 1592, 2125, 47, 822, "Input"],Cell[80668, 1641, 344, 9, 93, "Text"],Cell[81015, 1652, 3115, 68, 1242, "Input"]}]*)(*******************************************************************End of Mathematica Notebook file.*******************************************************************)